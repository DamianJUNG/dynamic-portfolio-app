# -*- coding: utf-8 -*-
"""ë™ì ìì‚°ë°°ë¶„ë°±í…ŒìŠ¤íŠ¸ ì•±ver1.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QcNKfr9cFk6QJ20Whk18kBZWhbp2YGsv
"""

import streamlit as st
import pandas as pd
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from dataclasses import dataclass, field
from pandas.tseries.offsets import BusinessDay, MonthEnd, WeekOfMonth
from typing import List, Dict, Tuple, Optional, Union
import warnings
import io
import base64
from datetime import datetime, timedelta
import time
import traceback

warnings.filterwarnings('ignore')

# í˜ì´ì§€ ì„¤ì •
st.set_page_config(
    page_title="ë™ì ìì‚°ë°°ë¶„ ë°±í…ŒìŠ¤íŠ¸ ì•± ver1.0",
    page_icon="ğŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS ìŠ¤íƒ€ì¼ë§
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        color: #1f77b4;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
    .success-box {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .warning-box {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .info-box {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .comparison-table {
        font-size: 0.9rem;
    }
</style>
""", unsafe_allow_html=True)

# ë°ì´í„° í´ë˜ìŠ¤ ì •ì˜
@dataclass
class AssetConfig:
    asset_ticker: str
    weight_decimal: float
    original_weight_input: float
    indicator_ticker: str
    sma_period: int

    def __repr__(self):
        return (f"AssetConfig(ìì‚°='{self.asset_ticker}', ì…ë ¥ë¹„ìœ¨={self.original_weight_input:.1f}%, "
                f"ìµœì¢…ì ìš©ë¹„ìœ¨={self.weight_decimal*100:.1f}%, "
                f"ì§€í‘œ='{self.indicator_ticker}', MAê¸°ê°„={self.sma_period})")

@dataclass
class LiveSignal:
    date: pd.Timestamp
    asset_ticker: str
    current_price: float
    indicator_price: float
    sma_value: float
    momentum_signal: bool
    recommended_weight: float
    signal_strength: float

    def __repr__(self):
        signal_text = "ğŸŸ¢ ë§¤ìˆ˜" if self.momentum_signal else "ğŸ”´ í˜„ê¸ˆëŒ€ê¸°"
        return (f"{self.asset_ticker}: {signal_text} | "
                f"í˜„ì¬ê°€(ì§€í‘œ): ${self.indicator_price:.2f} | "
                f"SMA: ${self.sma_value:.2f} | "
                f"ê¶Œì¥ë¹„ì¤‘: {self.recommended_weight*100:.1f}% | "
                f"ì‹ í˜¸ê°•ë„: {self.signal_strength:+.1f}%")

# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
@st.cache_data
def calculate_drawdown(cumulative_returns_series: pd.Series) -> pd.Series:
    """ë“œë¡œìš°ë‹¤ìš´ ê³„ì‚°"""
    try:
        if cumulative_returns_series.empty or cumulative_returns_series.isnull().all():
            return pd.Series(dtype='float64', index=cumulative_returns_series.index)

        processed_series = cumulative_returns_series.ffill()
        if pd.isna(processed_series.iloc[0]):
            processed_series = processed_series.bfill()
        if processed_series.isnull().all():
            return pd.Series(dtype='float64', index=processed_series.index)

        peak = processed_series.cummax()
        peak = peak.replace(0, np.nan).ffill().bfill().fillna(1e-9)
        drawdown = (processed_series / peak) - 1
        return drawdown
    except Exception as e:
        st.error(f"ë“œë¡œìš°ë‹¤ìš´ ê³„ì‚° ì˜¤ë¥˜: {e}")
        return pd.Series(dtype='float64')

def validate_ticker(ticker: str) -> bool:
    """í‹°ì»¤ ìœ íš¨ì„± ê²€ì¦"""
    if not ticker or len(ticker) < 1 or len(ticker) > 10:
        return False
    import re
    return bool(re.match(r'^[A-Z0-9.-]+$', ticker))

# ì‹œì¥ ë°ì´í„° ì œê³µì í´ë˜ìŠ¤
class MarketDataProvider:
    def __init__(self, asset_configs: List[AssetConfig], start_date: str, end_date: str):
        self.asset_configs = asset_configs
        self.data_start_date = pd.to_datetime(start_date)
        self.data_end_date = pd.to_datetime(end_date)
        self.all_tickers = self._get_all_unique_tickers()
        self.raw_data = {}
        self.price_data = {}
        self.sma_data = {}
        self.failed_tickers = []

    def _get_all_unique_tickers(self) -> List[str]:
        tickers = set()
        for ac in self.asset_configs:
            if validate_ticker(ac.asset_ticker):
                tickers.add(ac.asset_ticker)
            if validate_ticker(ac.indicator_ticker):
                tickers.add(ac.indicator_ticker)
        return sorted(list(tickers))

    def _download_data(self, ticker: str, start_date: pd.Timestamp, end_date: pd.Timestamp) -> pd.DataFrame:
        """ë°ì´í„° ë‹¤ìš´ë¡œë“œ (ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”)"""
        try:
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    df = yf.download(
                        ticker,
                        start=start_date,
                        end=end_date,
                        progress=False,
                        auto_adjust=False,
                        timeout=30
                    )
                    if df.empty:
                        if attempt < max_retries - 1:
                            time.sleep(1)
                            continue
                        else:
                            return pd.DataFrame()

                    if isinstance(df.columns, pd.MultiIndex):
                        df.columns = df.columns.get_level_values(0)
                        df = df.loc[:, ~df.columns.duplicated(keep='first')]

                    if 'Adj Close' not in df.columns:
                        if 'Close' in df.columns:
                            df['Adj Close'] = df['Close']
                        else:
                            return pd.DataFrame()

                    for col in ['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']:
                        if col in df.columns:
                            df[col] = pd.to_numeric(df[col], errors='coerce')

                    df_clean = df.dropna(subset=['Adj Close'])
                    if len(df_clean) < 10:
                        return pd.DataFrame()

                    return df_clean

                except Exception as retry_error:
                    if attempt < max_retries - 1:
                        time.sleep(2)
                        continue
                    else:
                        raise retry_error

        except Exception as e:
            st.warning(f"âš ï¸ {ticker} ë°ì´í„° ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
            self.failed_tickers.append(ticker)
            return pd.DataFrame()

    def load_all_data(self):
        """ëª¨ë“  ë°ì´í„° ë¡œë“œ"""
        if not self.all_tickers:
            st.error("ìœ íš¨í•œ í‹°ì»¤ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return False

        progress_bar = st.progress(0)
        status_text = st.empty()
        successful_downloads = 0

        for i, ticker in enumerate(self.all_tickers):
            status_text.text(f'ğŸ“¡ ë°ì´í„° ë‹¤ìš´ë¡œë“œ ì¤‘: {ticker} ({i+1}/{len(self.all_tickers)})')
            df = self._download_data(ticker, self.data_start_date, self.data_end_date)

            if not df.empty:
                self.raw_data[ticker] = df
                if 'Adj Close' in df.columns:
                    self.price_data[ticker] = df['Adj Close'].copy()
                    successful_downloads += 1
                    st.success(f"âœ… {ticker}: {len(df)}ê°œ ë°ì´í„° í¬ì¸íŠ¸")
            else:
                st.warning(f"âŒ {ticker}: ë°ì´í„° ì—†ìŒ")

            progress_bar.progress((i + 1) / len(self.all_tickers))

        if successful_downloads == 0:
            st.error("ëª¨ë“  í‹°ì»¤ì—ì„œ ë°ì´í„° ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
            return False

        status_text.text('ğŸ“Š SMA ê³„ì‚° ì¤‘...')

        try:
            for ac in self.asset_configs:
                sma_key = (ac.indicator_ticker, ac.sma_period)
                if sma_key in self.sma_data:
                    continue

                if ac.indicator_ticker in self.price_data:
                    price_series = self.price_data[ac.indicator_ticker]
                    if len(price_series) >= ac.sma_period:
                        sma_series = price_series.rolling(
                            window=ac.sma_period,
                            min_periods=ac.sma_period
                        ).mean()
                        self.sma_data[sma_key] = sma_series
                    else:
                        st.warning(f"âš ï¸ {ac.indicator_ticker}: SMA {ac.sma_period}ì¼ ê³„ì‚°ì— í•„ìš”í•œ ë°ì´í„° ë¶€ì¡±")
                        self.sma_data[sma_key] = pd.Series(dtype=float, index=price_series.index)
                else:
                    st.warning(f"âš ï¸ {ac.indicator_ticker}: ê°€ê²© ë°ì´í„° ì—†ìŒ")
                    self.sma_data[sma_key] = pd.Series(dtype=float)
        except Exception as e:
            st.error(f"SMA ê³„ì‚° ì˜¤ë¥˜: {e}")
            return False

        progress_bar.empty()
        status_text.empty()

        if self.failed_tickers:
            st.warning(f"âš ï¸ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ í‹°ì»¤: {', '.join(self.failed_tickers)}")

        st.success(f"âœ… ì´ {successful_downloads}/{len(self.all_tickers)}ê°œ í‹°ì»¤ ë°ì´í„° ë¡œë“œ ì™„ë£Œ")
        return successful_downloads > 0

    def get_price_on_date(self, ticker: str, date: pd.Timestamp) -> Optional[float]:
        try:
            if ticker in self.price_data:
                series = self.price_data[ticker]
                if date in series.index:
                    price = series.loc[date]
                else:
                    price = series.asof(date)
                return float(price) if pd.notna(price) else None
            return None
        except Exception:
            return None

    def get_sma_on_date(self, indicator_ticker: str, sma_period: int, date: pd.Timestamp) -> Optional[float]:
        try:
            sma_key = (indicator_ticker, sma_period)
            if sma_key in self.sma_data:
                series = self.sma_data[sma_key]
                if series.empty:
                    return None
                if date in series.index:
                    sma_value = series.loc[date]
                else:
                    sma_value = series.asof(date)
                return float(sma_value) if pd.notna(sma_value) else None
            return None
        except Exception:
            return None

    def get_return_for_period(self, ticker: str, start_date: pd.Timestamp, end_date: pd.Timestamp) -> float:
        try:
            price_start = self.get_price_on_date(ticker, start_date)
            price_end = self.get_price_on_date(ticker, end_date)
            if price_start is not None and price_end is not None and price_start != 0:
                return (price_end / price_start) - 1
            return 0.0
        except Exception:
            return 0.0

# í¬íŠ¸í´ë¦¬ì˜¤ í´ë˜ìŠ¤
class Portfolio:
    def __init__(self, initial_capital: float):
        self.initial_capital = float(initial_capital)
        self.current_value = float(initial_capital)
        self.weights = {'CASH': 1.0}
        self.history = []

    def get_current_cash_value(self) -> float:
        return self.current_value * self.weights.get('CASH', 0.0)

    def record_state(self, date: pd.Timestamp, action_notes: str = ""):
        self.history.append({
            'date': date,
            'portfolio_value': round(self.current_value, 2),
            'weights': {k: round(v, 4) for k, v in self.weights.items() if abs(v) > 1e-6},
            'cash_value': round(self.get_current_cash_value(), 2),
            'notes': action_notes
        })

    def update_value_from_period_returns(self, period_asset_returns: Dict[str, float]):
        if not self.weights:
            return

        portfolio_period_return = 0.0
        for asset_ticker, weight in self.weights.items():
            asset_return = period_asset_returns.get(asset_ticker, 0.0)
            if pd.isna(asset_return):
                asset_return = 0.0
            portfolio_period_return += weight * asset_return

        self.current_value *= (1 + portfolio_period_return)

    def rebalance_to_target_weights(self, target_weights: Dict[str, float],
                                   transaction_cost_rate: float, slippage_rate: float) -> float:
        total_weight_change = 0.0
        all_assets = set(self.weights.keys()) | set(target_weights.keys())

        for asset_ticker in all_assets:
            current_w = self.weights.get(asset_ticker, 0.0)
            target_w = target_weights.get(asset_ticker, 0.0)
            total_weight_change += abs(target_w - current_w)

        traded_portion = total_weight_change / 2.0
        costs = self.current_value * traded_portion * (transaction_cost_rate + slippage_rate)

        self.current_value -= costs
        if self.current_value < 0:
            self.current_value = 0.0

        self.weights = {k: v for k, v in target_weights.items() if abs(v) > 1e-6}
        current_sum_weights = sum(self.weights.values())
        if abs(current_sum_weights - 1.0) > 1e-6 and current_sum_weights > 0:
            for k in self.weights:
                self.weights[k] /= current_sum_weights

        return costs

    def apply_cash_flow(self, amount: float):
        """
        ë§¤ì›”ë§ì— ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‚©ì… ë˜ëŠ” ì¸ì¶œ ê¸ˆì•¡ì„ í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ì— ë°˜ì˜.
        amount > 0 ì´ë©´ ë‚©ì…(ì…ê¸ˆ), amount < 0 ì´ë©´ ì¸ì¶œ(ì¶œê¸ˆ).
        """
        self.current_value += amount
        # ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡ ìµœì†Œ 0ìœ¼ë¡œ ì²˜ë¦¬
        if self.current_value < 0:
            self.current_value = 0.0

# ë°±í…ŒìŠ¤í„° í´ë˜ìŠ¤
class Backtester:
    def __init__(self, asset_configs: List[AssetConfig], backtest_params: Dict,
                 market_data_provider: MarketDataProvider):
        self.asset_configs = asset_configs
        self.params = backtest_params
        self.dataprovider = market_data_provider
        self.portfolio = Portfolio(self.params['initial_capital'])
        self.benchmark_portfolio = Portfolio(self.params['initial_capital'])
        self._setup_initial_benchmark_weights()
        self.rebalancing_dates = self._generate_rebalancing_dates()
        self.trade_log = []
        # í˜„ê¸ˆ íë¦„ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        self.cashflow_enabled = self.params.get('cashflow_enabled', False)
        self.cashflow_amount = self.params.get('cashflow_amount', 0.0)
        self.cashflow_type = self.params.get('cashflow_type', 'ë‚©ì…')  # 'ë‚©ì…' ë˜ëŠ” 'ì¸ì¶œ'

    def _generate_rebalancing_dates(self) -> pd.DatetimeIndex:
        try:
            if not self.asset_configs:
                return pd.DatetimeIndex([])

            ref_ticker = self.asset_configs[0].indicator_ticker
            if ref_ticker not in self.dataprovider.price_data:
                st.warning(f"ê¸°ì¤€ í‹°ì»¤ {ref_ticker} ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
                return pd.DatetimeIndex([])

            reference_index = self.dataprovider.price_data[ref_ticker].index.sort_values().unique()
            temp_series = pd.Series(data=1, index=reference_index)

            backtest_start = pd.to_datetime(self.params['start_date'])
            backtest_end = pd.to_datetime(self.params['end_date'])
            freq = self.params['frequency']

            if freq == 'M':
                candidate_dates = temp_series.resample('BME').last().index
            elif freq == 'W-FRI':
                candidate_dates = temp_series.resample('W-FRI').last().index
            else:
                candidate_dates = temp_series.resample('BME').last().index

            adjusted_dates = []
            for date_candidate in candidate_dates:
                actual_date = date_candidate
                if actual_date not in reference_index:
                    future_dates = reference_index[reference_index > date_candidate]
                    if not future_dates.empty:
                        actual_date = future_dates[0]
                    else:
                        continue

                if backtest_start <= actual_date <= backtest_end:
                    adjusted_dates.append(actual_date)

            return pd.DatetimeIndex(sorted(list(set(adjusted_dates)))).unique()

        except Exception as e:
            st.error(f"ë¦¬ë°¸ëŸ°ì‹± ë‚ ì§œ ìƒì„± ì˜¤ë¥˜: {e}")
            return pd.DatetimeIndex([])

    def _get_momentum_decision(self, asset_config: AssetConfig, date: pd.Timestamp) -> bool:
        """
        ëª¨ë©˜í…€ ê²°ì •ì„ ìœ„í•´ ì§€í‘œ ìì‚°ì˜ ê°€ê²©ê³¼ ì§€í‘œ ìì‚°ì˜ SMAë¥¼ ë¹„êµí•˜ë„ë¡ ìˆ˜ì •.
        """
        try:
            # ì§€í‘œ ìì‚°ì˜ ê°€ê²©ì„ ê°€ì ¸ì˜´
            indicator_price = self.dataprovider.get_price_on_date(asset_config.indicator_ticker, date)
            sma = self.dataprovider.get_sma_on_date(asset_config.indicator_ticker,
                                                   asset_config.sma_period, date)
            if indicator_price is None or sma is None:
                return False
            return indicator_price > sma
        except Exception:
            return False

    def _calculate_target_weights(self, momentum_assets: List[AssetConfig]) -> Dict[str, float]:
        target_weights = {}
        method = self.params['rebalancing_method']

        if not momentum_assets:
            target_weights['CASH'] = 1.0
            return target_weights

        if method == 'A':
            sum_weights = sum(ac.original_weight_input for ac in momentum_assets)
            if abs(sum_weights) < 1e-9:
                target_weights['CASH'] = 1.0
                return target_weights
            for ac in momentum_assets:
                target_weights[ac.asset_ticker] = ac.original_weight_input / sum_weights
        elif method == 'B':
            total_weight = 0.0
            for ac in momentum_assets:
                target_weights[ac.asset_ticker] = ac.weight_decimal
                total_weight += ac.weight_decimal
            cash_weight = 1.0 - total_weight
            if cash_weight > 1e-6:
                target_weights['CASH'] = max(0, cash_weight)

        return {k: v for k, v in target_weights.items() if abs(v) > 1e-6}

    def _setup_initial_benchmark_weights(self):
        initial_weights = {ac.asset_ticker: ac.weight_decimal for ac in self.asset_configs}
        cash_w = 1.0 - sum(initial_weights.values())
        if cash_w > 1e-6:
            initial_weights['CASH'] = cash_w
        self.benchmark_portfolio.weights = initial_weights.copy()

    def run_backtest(self):
        try:
            if self.rebalancing_dates.empty:
                st.error("ë¦¬ë°¸ëŸ°ì‹± ë‚ ì§œê°€ ì—†ìŠµë‹ˆë‹¤.")
                return [], [], []

            first_date = self.rebalancing_dates[0]
            self.portfolio.record_state(first_date, "Initial State")
            self.benchmark_portfolio.record_state(first_date, "Initial Benchmark State")

            progress_bar = st.progress(0)
            status_text = st.empty()

            for i, current_date in enumerate(self.rebalancing_dates):
                status_text.text(f'âš™ï¸ ë°±í…ŒìŠ¤íŠ¸ ì§„í–‰: {current_date.strftime("%Y-%m-%d")} ({i+1}/{len(self.rebalancing_dates)})')

                prev_date = self.portfolio.history[-1]['date']

                if current_date > prev_date:
                    # 1) ì „ëµ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì—…ë°ì´íŠ¸ (ìˆ˜ìµë¥  ë°˜ì˜)
                    strategy_returns = {
                        asset: (0.0 if asset == 'CASH' else
                               self.dataprovider.get_return_for_period(asset, prev_date, current_date))
                        for asset in self.portfolio.weights.keys()
                    }
                    self.portfolio.update_value_from_period_returns(strategy_returns)

                    # â‘¡ í˜„ê¸ˆ íë¦„ ì ìš© (ì›”ë§ ë¦¬ë°¸ëŸ°ì‹± ë•Œë§Œ ì‹¤í–‰)
                    if self.cashflow_enabled and self.params['frequency'] == 'M':
                        # cashflow_typeì´ 'ë‚©ì…'ì´ë©´ +amount, 'ì¸ì¶œ'ì´ë©´ -amount
                        cf_amount = self.cashflow_amount if self.cashflow_type == 'ë‚©ì…' else -self.cashflow_amount
                        self.portfolio.apply_cash_flow(cf_amount)

                    # â‘¢ ë²¤ì¹˜ë§ˆí¬ëŠ” í˜„ê¸ˆ íë¦„ ì ìš© ì—†ì´ ìˆ˜ìµë¥ ë§Œ ë°˜ì˜
                    benchmark_returns = {
                        asset: (0.0 if asset == 'CASH' else
                               self.dataprovider.get_return_for_period(asset, prev_date, current_date))
                        for asset in self.benchmark_portfolio.weights.keys()
                    }
                    self.benchmark_portfolio.update_value_from_period_returns(benchmark_returns)

                # â‘£ ëª¨ë©˜í…€ ì‹ í˜¸ í™•ì¸ ë° ë¦¬ë°¸ëŸ°ì‹±
                momentum_assets = [
                    ac for ac in self.asset_configs
                    if self._get_momentum_decision(ac, current_date)
                ]
                target_weights = self._calculate_target_weights(momentum_assets)

                value_before = self.portfolio.current_value
                costs = self.portfolio.rebalance_to_target_weights(
                    target_weights,
                    self.params['transaction_cost_rate'],
                    self.params['slippage_rate']
                )

                self.trade_log.append({
                    'date': current_date,
                    'target_weights': {
                        k: round(v, 4)
                        for k, v in target_weights.items() if abs(v) > 1e-6
                    },
                    'portfolio_value_before_costs': round(value_before, 2),
                    'transaction_costs': round(costs, 2),
                    'portfolio_value_after_costs': round(self.portfolio.current_value, 2)
                })

                self.portfolio.record_state(current_date, "Rebalanced")
                self.benchmark_portfolio.record_state(current_date, "Benchmark Update")

                progress_bar.progress((i + 1) / len(self.rebalancing_dates))

            progress_bar.empty()
            status_text.empty()

            return self.portfolio.history, self.benchmark_portfolio.history, self.trade_log

        except Exception as e:
            st.error(f"ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            return [], [], []

# ì‹¤ì‹œê°„ ì‹ í˜¸ ìƒì„±ê¸°
class LiveSignalGenerator:
    def __init__(self, asset_configs: List[AssetConfig], dataprovider: MarketDataProvider):
        self.asset_configs = asset_configs
        self.dataprovider = dataprovider

    def generate_signals(self, target_date: pd.Timestamp, method: str = 'A') -> Tuple[List[LiveSignal], Dict[str, float]]:
        signals = []
        momentum_assets = []

        for config in self.asset_configs:
            # ì§€í‘œ ìì‚°ì˜ ê°€ê²©ì„ ê°€ì ¸ì˜´
            indicator_price = self.dataprovider.get_price_on_date(config.indicator_ticker, target_date)
            sma_value = self.dataprovider.get_sma_on_date(config.indicator_ticker,
                                                        config.sma_period, target_date)

            if indicator_price is None or sma_value is None:
                continue

            # ì§€í‘œ ìì‚° ê°€ê²©ê³¼ SMAë¥¼ ë¹„êµ
            momentum_signal = indicator_price > sma_value
            # ì‹ í˜¸ ê°•ë„ ê³„ì‚°ë„ ì§€í‘œ ìì‚° ê°€ê²© ê¸°ì¤€ìœ¼ë¡œ ìˆ˜ì •
            signal_strength = ((indicator_price / sma_value) - 1) * 100

            # LiveSignalì— asset_tickerëŠ” ê·¸ëŒ€ë¡œ, current_priceì—ëŠ” ì§€í‘œ ê°€ê²©ì„ í‘œì‹œ
            signal = LiveSignal(
                date=target_date,
                asset_ticker=config.asset_ticker,
                current_price=indicator_price,
                indicator_price=indicator_price,
                sma_value=sma_value,
                momentum_signal=momentum_signal,
                recommended_weight=0.0,
                signal_strength=signal_strength
            )

            signals.append(signal)
            if momentum_signal:
                momentum_assets.append(config)

        # í¬íŠ¸í´ë¦¬ì˜¤ ë¹„ì¤‘ ê³„ì‚°
        portfolio_weights = self._calculate_portfolio_weights(momentum_assets, method)

        # ì‹ í˜¸ì— ê¶Œì¥ ë¹„ì¤‘ ì—…ë°ì´íŠ¸
        for signal in signals:
            signal.recommended_weight = portfolio_weights.get(signal.asset_ticker, 0.0)

        return signals, portfolio_weights

    def _calculate_portfolio_weights(self, momentum_assets: List[AssetConfig], method: str) -> Dict[str, float]:
        weights = {}

        if not momentum_assets:
            weights['CASH'] = 1.0
            return weights

        if method == 'A':
            total_weight = sum(ac.original_weight_input for ac in momentum_assets)
            if total_weight > 0:
                for ac in momentum_assets:
                    weights[ac.asset_ticker] = ac.original_weight_input / total_weight
            else:
                weights['CASH'] = 1.0
        elif method == 'B':
            total_weight = 0.0
            for ac in momentum_assets:
                weights[ac.asset_ticker] = ac.weight_decimal
                total_weight += ac.weight_decimal

            cash_weight = 1.0 - total_weight
            if cash_weight > 0:
                weights['CASH'] = cash_weight

        return weights

# ë¶„ì„ í•¨ìˆ˜ë“¤
def history_to_df(history_list: List[Dict]) -> pd.DataFrame:
    if not history_list:
        return pd.DataFrame()
    df = pd.DataFrame(history_list)
    df['date'] = pd.to_datetime(df['date'])
    return df.set_index('date').sort_index()

def calculate_annual_returns(portfolio_df: pd.DataFrame, initial_capital: float) -> pd.DataFrame:
    """ì—°ê°„ ìˆ˜ìµë¥  ê³„ì‚°"""
    try:
        if portfolio_df.empty or 'portfolio_value' not in portfolio_df.columns:
            return pd.DataFrame()

        annual_values = portfolio_df['portfolio_value'].resample('Y').last()
        annual_returns = []
        prev_value = initial_capital

        for year, end_value in annual_values.items():
            if pd.isna(end_value):
                continue

            year_return = (end_value / prev_value - 1) * 100
            annual_returns.append({
                'Year': year.year,
                'Start_Value': prev_value,
                'End_Value': end_value,
                'Return_Pct': year_return,
                'Profit_Loss': end_value - prev_value
            })
            prev_value = end_value

        return pd.DataFrame(annual_returns)

    except Exception as e:
        st.error(f"ì—°ê°„ ìˆ˜ìµë¥  ê³„ì‚° ì˜¤ë¥˜: {e}")
        return pd.DataFrame()

def calculate_performance_metrics(portfolio_df: pd.DataFrame, params: Dict) -> Dict:
    """ì„±ê³¼ ì§€í‘œ ê³„ì‚°"""
    try:
        if portfolio_df.empty or 'portfolio_value' not in portfolio_df.columns:
            return {}

        start_value = params['initial_capital']
        end_value = portfolio_df['portfolio_value'].iloc[-1]
        start_date = portfolio_df.index[0]
        end_date = portfolio_df.index[-1]
        years = (end_date - start_date).days / 365.25

        if years > 0 and start_value > 0:
            cagr = (end_value / start_value) ** (1 / years) - 1
        else:
            cagr = 0

        returns = portfolio_df['portfolio_value'].pct_change().dropna()
        total_return = (end_value / start_value - 1) * 100

        if len(returns) > 1:
            volatility = returns.std() * np.sqrt(252) * 100
            risk_free_rate = params.get('risk_free_rate', 0.02)
            if volatility > 0:
                sharpe = (cagr - risk_free_rate) / (volatility / 100)
            else:
                sharpe = 0
        else:
            volatility = 0
            sharpe = 0

        cumulative = portfolio_df['portfolio_value'] / start_value
        drawdown = calculate_drawdown(cumulative)
        max_dd = drawdown.min() * 100 if not drawdown.empty else 0

        if len(returns) > 0:
            win_rate = (returns > 0).sum() / len(returns) * 100
        else:
            win_rate = 0

        return {
            'CAGR (%)': cagr * 100,
            'Total Return (%)': total_return,
            'Volatility (%)': volatility,
            'Sharpe Ratio': sharpe,
            'Max Drawdown (%)': max_dd,
            'Win Rate (%)': win_rate,
            'Final Value': end_value,
            'Profit/Loss': end_value - start_value
        }

    except Exception as e:
        st.error(f"ì„±ê³¼ ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜: {e}")
        return {}

# ì‹œê°í™” í•¨ìˆ˜ë“¤
def create_performance_chart(strategy_df: pd.DataFrame, benchmark_df: pd.DataFrame, initial_capital: float):
    """ì„±ê³¼ ì°¨íŠ¸ ìƒì„± (ìˆ˜ìµë¥  + MDD)"""
    try:
        fig = make_subplots(
            rows=2, cols=1,
            subplot_titles=('ğŸ“ˆ ëˆ„ì  ìˆ˜ìµë¥  ë¹„êµ', 'ğŸ“‰ ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´ (MDD)'),
            vertical_spacing=0.12,
            row_heights=[0.65, 0.35],
            specs=[[{"secondary_y": False}], [{"secondary_y": False}]]
        )

        if not strategy_df.empty and 'portfolio_value' in strategy_df.columns:
            strategy_cum = strategy_df['portfolio_value'] / initial_capital
            fig.add_trace(
                go.Scatter(
                    x=strategy_df.index,
                    y=strategy_cum,
                    name='ë™ì ìì‚°ë°°ë¶„ ì „ëµ',
                    line=dict(color='#1f77b4', width=3),
                    hovertemplate='ë‚ ì§œ: %{x}<br>ìˆ˜ìµë¥  ë°°ìˆ˜: %{y:.3f}<extra></extra>'
                ),
                row=1, col=1
            )

        if not benchmark_df.empty and 'portfolio_value' in benchmark_df.columns:
            benchmark_cum = benchmark_df['portfolio_value'] / initial_capital
            fig.add_trace(
                go.Scatter(
                    x=benchmark_df.index,
                    y=benchmark_cum,
                    name='Buy & Hold ë²¤ì¹˜ë§ˆí¬',
                    line=dict(color='#ff7f0e', width=2, dash='dash'),
                    hovertemplate='ë‚ ì§œ: %{x}<br>ìˆ˜ìµë¥  ë°°ìˆ˜: %{y:.3f}<extra></extra>'
                ),
                row=1, col=1
            )

        if not strategy_df.empty:
            strategy_dd = calculate_drawdown(strategy_cum) * 100
            fig.add_trace(
                go.Scatter(
                    x=strategy_df.index,
                    y=strategy_dd,
                    name='ì „ëµ MDD',
                    fill='tonexty',
                    fillcolor='rgba(255, 0, 0, 0.2)',
                    line=dict(color='red', width=2),
                    hovertemplate='ë‚ ì§œ: %{x}<br>ë“œë¡œìš°ë‹¤ìš´: %{y:.2f}%<extra></extra>'
                ),
                row=2, col=1
            )

        if not benchmark_df.empty:
            benchmark_dd = calculate_drawdown(benchmark_cum) * 100
            fig.add_trace(
                go.Scatter(
                    x=benchmark_df.index,
                    y=benchmark_dd,
                    name='ë²¤ì¹˜ë§ˆí¬ MDD',
                    line=dict(color='orange', width=2, dash='dot'),
                    hovertemplate='ë‚ ì§œ: %{x}<br>ë“œë¡œìš°ë‹¤ìš´: %{y:.2f}%<extra></extra>'
                ),
                row=2, col=1
            )

        fig.update_layout(
            height=700,
            showlegend=True,
            title=dict(
                text="<b>ë™ì ìì‚°ë°°ë¶„ vs Buy & Hold ì„±ê³¼ ë¹„êµ</b>",
                x=0.5,
                font=dict(size=16)
            ),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )

        fig.update_yaxes(title_text="ëˆ„ì  ìˆ˜ìµë¥  (ë°°ìˆ˜)", row=1, col=1)
        fig.update_yaxes(title_text="ë“œë¡œìš°ë‹¤ìš´ (%)", row=2, col=1)
        fig.update_xaxes(title_text="ë‚ ì§œ", row=2, col=1)
        fig.add_hline(y=0, line_dash="dash", line_color="black", row=2, col=1)

        return fig

    except Exception as e:
        st.error(f"ì„±ê³¼ ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
        return None

def create_signals_chart(signals: List[LiveSignal]):
    """ì‹ í˜¸ ì°¨íŠ¸ ìƒì„±"""
    try:
        if not signals:
            return None

        fig = go.Figure()

        assets = [s.asset_ticker for s in signals]
        colors = ['#00cc44' if s.momentum_signal else '#ff4444' for s in signals]
        strengths = [s.signal_strength for s in signals]

        fig.add_trace(go.Bar(
            x=assets,
            y=strengths,
            marker_color=colors,
            text=[f"{s:+.1f}%" for s in strengths],
            textposition='auto',
            hovertemplate='ìì‚°: %{x}<br>ì‹ í˜¸ ê°•ë„: %{y:.1f}%<extra></extra>'
        ))

        fig.update_layout(
            title="<b>ğŸ“Š ìì‚°ë³„ ëª¨ë©˜í…€ ì‹ í˜¸ ê°•ë„</b>",
            xaxis_title="ìì‚°",
            yaxis_title="ì‹ í˜¸ ê°•ë„ (%)",
            yaxis=dict(tickformat='.1f'),
            height=400,
            showlegend=False
        )

        fig.add_hline(y=0, line_dash="dash", line_color="black")

        return fig

    except Exception as e:
        st.error(f"ì‹ í˜¸ ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
        return None

def create_annual_comparison_chart(strategy_annual: pd.DataFrame, benchmark_annual: pd.DataFrame):
    """ì—°ê°„ ìˆ˜ìµë¥  ë¹„êµ ì°¨íŠ¸"""
    try:
        if strategy_annual.empty and benchmark_annual.empty:
            return None

        fig = go.Figure()

        if not strategy_annual.empty:
            fig.add_trace(go.Bar(
                x=strategy_annual['Year'],
                y=strategy_annual['Return_Pct'],
                name='ë™ì ìì‚°ë°°ë¶„ ì „ëµ',
                marker_color='#1f77b4',
                hovertemplate='ì—°ë„: %{x}<br>ìˆ˜ìµë¥ : %{y:.1f}%<extra></extra>'
            ))

        if not benchmark_annual.empty:
            fig.add_trace(go.Bar(
                x=benchmark_annual['Year'],
                y=benchmark_annual['Return_Pct'],
                name='Buy & Hold ë²¤ì¹˜ë§ˆí¬',
                marker_color='#ff7f0e',
                hovertemplate='ì—°ë„: %{x}<br>ìˆ˜ìµë¥ : %{y:.1f}%<extra></extra>'
            ))

        fig.update_layout(
            title="<b>ğŸ“Š ì—°ê°„ ìˆ˜ìµë¥  ë¹„êµ</b>",
            xaxis_title="ì—°ë„",
            yaxis_title="ìˆ˜ìµë¥  (%)",
            height=400,
            barmode='group'
        )

        fig.add_hline(y=0, line_dash="dash", line_color="black")

        return fig

    except Exception as e:
        st.error(f"ì—°ê°„ ë¹„êµ ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
        return None

# ë©”ì¸ ì•±
def main():
    try:
        st.markdown('<h1 class="main-header">ğŸ“Š ë™ì ìì‚°ë°°ë¶„ ë°±í…ŒìŠ¤íŠ¸ ì•± ver1.0</h1>', unsafe_allow_html=True)

        st.markdown("""
        <div class="info-box">
        <h4>ğŸ¯ ëª¨ë©˜í…€ ê¸°ë°˜ ë™ì ìì‚°ë°°ë¶„ ì „ëµ</h4>
        <p>ì´ë™í‰ê· ì„ í™œìš©í•œ ë™ì  ìì‚°ë°°ë¶„ ì „ëµì˜ ë°±í…ŒìŠ¤íŠ¸ì™€ ì‹¤ì‹œê°„ íˆ¬ì ì‹ í˜¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.</p>
        <p><strong>ì£¼ìš” íŠ¹ì§•:</strong> Buy & Hold ëŒ€ë¹„ ì„±ê³¼ ë¶„ì„, MDD ê´€ë¦¬, ì‹¤ì‹œê°„ ì‹ í˜¸ ìƒì„±</p>
        </div>
        """, unsafe_allow_html=True)

        # ì‚¬ì´ë“œë°” - ì…ë ¥ íŒ¨ë„
        with st.sidebar:
            st.header("ğŸ“‹ ì „ëµ ì„¤ì •")

            # 1) í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±
            st.subheader("1. í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±")
            if 'asset_configs' not in st.session_state:
                st.session_state.asset_configs = []

            with st.expander("ìì‚° ì¶”ê°€", expanded=True):
                with st.form("add_asset"):
                    col1, col2 = st.columns(2)
                    with col1:
                        asset_ticker = st.text_input("ìì‚° í‹°ì»¤", placeholder="ì˜ˆ: SPY").upper().strip()
                        weight = st.number_input("íˆ¬ì ë¹„ìœ¨ (%)", min_value=0.0, max_value=100.0, value=25.0)
                    with col2:
                        indicator_ticker = st.text_input("ì§€í‘œ í‹°ì»¤", placeholder="ì˜ˆ: SPY").upper().strip()
                        sma_period = st.number_input("SMA ê¸°ê°„", min_value=5, max_value=500, value=200)

                    add_asset = st.form_submit_button("ìì‚° ì¶”ê°€")
                    if add_asset:
                        if not asset_ticker:
                            st.error("ìì‚° í‹°ì»¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                        elif not validate_ticker(asset_ticker):
                            st.error("ì˜¬ë°”ë¥¸ í‹°ì»¤ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.")
                        else:
                            if not indicator_ticker:
                                indicator_ticker = asset_ticker

                            new_config = AssetConfig(
                                asset_ticker=asset_ticker,
                                weight_decimal=weight/100.0,
                                original_weight_input=weight,
                                indicator_ticker=indicator_ticker,
                                sma_period=sma_period
                            )
                            st.session_state.asset_configs.append(new_config)
                            st.success(f"âœ… {asset_ticker} ì¶”ê°€ë¨!")
                            st.rerun()

            if st.session_state.asset_configs:
                st.subheader("í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤")
                total_weight = sum(ac.original_weight_input for ac in st.session_state.asset_configs)
                for i, config in enumerate(st.session_state.asset_configs):
                    col1, col2 = st.columns([3, 1])
                    with col1:
                        st.text(f"{config.asset_ticker}: {config.original_weight_input:.1f}%")
                    with col2:
                        if st.button("âŒ", key=f"del_{i}", help="ì‚­ì œ"):
                            st.session_state.asset_configs.pop(i)
                            st.rerun()

                if abs(total_weight - 100.0) > 0.1:
                    st.warning(f"âš ï¸ ì´ ë¹„ìœ¨: {total_weight:.1f}%")
                    if st.button("ğŸ”„ 100%ë¡œ ì •ê·œí™”", use_container_width=True):
                        for config in st.session_state.asset_configs:
                            config.weight_decimal = config.original_weight_input / total_weight
                        st.success("âœ… ì •ê·œí™” ì™„ë£Œ!")
                        st.rerun()
                else:
                    st.success(f"âœ… ì´ ë¹„ìœ¨: {total_weight:.1f}%")

            # 2) ë°±í…ŒìŠ¤íŠ¸ ì„¤ì •
            st.subheader("2. ë°±í…ŒìŠ¤íŠ¸ ì„¤ì •")
            col1, col2 = st.columns(2)
            with col1:
                start_year = st.selectbox("ì‹œì‘ ì—°ë„", range(2000, 2025), index=20)
                start_month = st.selectbox("ì‹œì‘ ì›”", range(1, 13), index=0)
            with col2:
                use_today = st.checkbox("ì˜¤ëŠ˜ê¹Œì§€ ë¶„ì„", value=True)
                if not use_today:
                    end_year = st.selectbox("ì¢…ë£Œ ì—°ë„", range(2000, 2026), index=24)
                    end_month = st.selectbox("ì¢…ë£Œ ì›”", range(1, 13), index=11)

            frequency = st.selectbox("ë¦¬ë°¸ëŸ°ì‹± ë¹ˆë„", ["ì›”ë§ (M)", "ì£¼ê°„ ê¸ˆìš”ì¼ (W)"], index=0)
            method = st.selectbox("ë¦¬ë°¸ëŸ°ì‹± ë°©ë²•",
                                  ["ìƒëŒ€ì  ë¹„ìœ¨ ìœ ì§€", "ê³ ì • ë¹„ìœ¨ + í˜„ê¸ˆ"], index=0)

            # 3) ê±°ë˜ ë¹„ìš©
            st.subheader("3. ê±°ë˜ ë¹„ìš©")
            col1, col2 = st.columns(2)
            with col1:
                slippage = st.number_input("ìŠ¬ë¦¬í”¼ì§€ (%)", min_value=0.0, max_value=1.0, value=0.05, step=0.01)
                transaction_cost = st.number_input("ê±°ë˜ ìˆ˜ìˆ˜ë£Œ (%)", min_value=0.0, max_value=1.0, value=0.05, step=0.01)
            with col2:
                initial_capital = st.number_input("ì´ˆê¸° ìë³¸ ($)", min_value=1000, value=10000, step=1000)
                risk_free_rate = st.number_input("ë¬´ìœ„í—˜ ì´ììœ¨ (%)", min_value=0.0, max_value=10.0, value=2.0, step=0.1)

            # 4) ì›”ë³„ í˜„ê¸ˆ íë¦„ ì„¤ì •
            st.subheader("4. ì›”ë³„ í˜„ê¸ˆ íë¦„ ì„¤ì •")
            cashflow_enabled = st.checkbox("ì›”ë³„ í˜„ê¸ˆ íë¦„ ì‚¬ìš©")
            if cashflow_enabled:
                cashflow_type = st.selectbox("ìœ í˜•", ["ë‚©ì…", "ì¸ì¶œ"], index=0)
                cashflow_amount = st.number_input("ê¸ˆì•¡ ($)", min_value=0.0, value=100.0, step=10.0)
            else:
                cashflow_type = "ë‚©ì…"
                cashflow_amount = 0.0

        # ìì‚°ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ ë°±í…ŒìŠ¤íŠ¸ ë¶ˆê°€
        if not st.session_state.asset_configs:
            st.warning("âš ï¸ í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±ì„ ìœ„í•´ ì‚¬ì´ë“œë°”ì—ì„œ ìì‚°ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.")
            st.subheader("ğŸ’¡ ìƒ˜í”Œ í¬íŠ¸í´ë¦¬ì˜¤")
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("ğŸ›ï¸ ì•ˆì •í˜•", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("SPY", 0.6, 60.0, "SPY", 200),
                        AssetConfig("TLT", 0.4, 40.0, "TLT", 200)
                    ]
                    st.rerun()
            with col2:
                if st.button("âš–ï¸ ê· í˜•í˜•", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("SPY", 0.4, 40.0, "SPY", 200),
                        AssetConfig("QQQ", 0.3, 30.0, "QQQ", 200),
                        AssetConfig("VEA", 0.3, 30.0, "VEA", 200)
                    ]
                    st.rerun()
            with col3:
                if st.button("ğŸš€ ê³µê²©í˜•", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("QQQ", 0.5, 50.0, "QQQ", 200),
                        AssetConfig("SPY", 0.3, 30.0, "SPY", 200),
                        AssetConfig("IWM", 0.2, 20.0, "IWM", 200)
                    ]
                    st.rerun()
            return

        # ë¶„ì„ ì‹œì‘ ë²„íŠ¼
        if st.button("ğŸš€ ë°±í…ŒìŠ¤íŠ¸ ì‹œì‘", type="primary", use_container_width=True):
            with st.spinner("ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤..."):
                # 1) ë‚ ì§œ íŒŒë¼ë¯¸í„° êµ¬ì„±
                start_date = f"{start_year}-{start_month:02d}-01"
                if use_today:
                    end_date = datetime.now().strftime('%Y-%m-%d')
                else:
                    end_date = f"{end_year}-{end_month:02d}-{pd.Period(f'{end_year}-{end_month}').days_in_month:02d}"

                backtest_params = {
                    'start_date': start_date,
                    'end_date': end_date,
                    'frequency': 'M' if frequency.startswith('ì›”ë§') else 'W-FRI',
                    'rebalancing_method': 'A' if method.startswith('ìƒëŒ€ì ') else 'B',
                    'slippage_rate': slippage / 100.0,
                    'transaction_cost_rate': transaction_cost / 100.0,
                    'initial_capital': initial_capital,
                    'risk_free_rate': risk_free_rate / 100.0,
                    'cashflow_enabled': cashflow_enabled,
                    'cashflow_type': cashflow_type,
                    'cashflow_amount': cashflow_amount
                }

                # 2) ë°ì´í„° ë²„í¼ ê³„ì‚°
                max_sma = max(ac.sma_period for ac in st.session_state.asset_configs)
                buffer_days = int(max_sma * 1.5 + 60)
                data_start = (pd.to_datetime(start_date) - pd.Timedelta(days=buffer_days)).strftime('%Y-%m-%d')

                # 3) ë°ì´í„° ë¡œë“œ
                dataprovider = MarketDataProvider(
                    st.session_state.asset_configs,
                    data_start,
                    end_date
                )
                success = dataprovider.load_all_data()
                if not success:
                    st.error("âŒ ë°ì´í„° ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í‹°ì»¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.")
                    return

                # 4) ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                backtester = Backtester(
                    st.session_state.asset_configs,
                    backtest_params,
                    dataprovider
                )
                strategy_history, benchmark_history, trade_log = backtester.run_backtest()
                if not strategy_history:
                    st.error("âŒ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.")
                    return

                # 5) ì‹¤ì‹œê°„ ì‹ í˜¸ ìƒì„±
                signal_generator = LiveSignalGenerator(
                    st.session_state.asset_configs,
                    dataprovider
                )
                end_date_ts = pd.to_datetime(end_date)
                signals, portfolio_weights = signal_generator.generate_signals(
                    end_date_ts,
                    backtest_params['rebalancing_method']
                )

                # 6) ê²°ê³¼ ë¶„ì„
                strategy_df = history_to_df(strategy_history)
                benchmark_df = history_to_df(benchmark_history)

                strategy_metrics = calculate_performance_metrics(strategy_df, backtest_params)
                benchmark_metrics = calculate_performance_metrics(benchmark_df, backtest_params)

                strategy_annual = calculate_annual_returns(strategy_df, initial_capital)
                benchmark_annual = calculate_annual_returns(benchmark_df, initial_capital)

                # 7) ê²°ê³¼ í‘œì‹œ
                st.success("âœ… ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")

                # **í˜„ê¸ˆ íë¦„ ì‚¬ìš© ì•ˆë‚´**
                if cashflow_enabled:
                    st.warning(
                        "âš ï¸ í˜„ê¸ˆ íë¦„ ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤. "
                        "CAGR ë° ì´ ìˆ˜ìµë¥  ë“±ì˜ ë¹„ìœ¨ ì§€í‘œëŠ” ì™¸ë¶€ í˜„ê¸ˆ ìœ ì…/ìœ ì¶œì˜ ì˜í–¥ì„ ë°›ì•„ ì™œê³¡ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. "
                        "ìµœì¢… ìì‚° ê°€ì¹˜ëŠ” ì •í™•íˆ ê³„ì‚°ë˜ì—ˆìŠµë‹ˆë‹¤."
                    )

                # í•µì‹¬ ì„±ê³¼ ì§€í‘œ
                st.header("ğŸ“Š í•µì‹¬ ì„±ê³¼ ì§€í‘œ")

                col1, col2, col3, col4, col5 = st.columns(5)

                with col1:
                    strategy_cagr = strategy_metrics.get('CAGR (%)', 0)
                    benchmark_cagr = benchmark_metrics.get('CAGR (%)', 0)
                    st.metric("ì „ëµ CAGR", f"{strategy_cagr:.2f}%",
                             f"{strategy_cagr - benchmark_cagr:+.2f}%p")

                with col2:
                    strategy_mdd = strategy_metrics.get('Max Drawdown (%)', 0)
                    benchmark_mdd = benchmark_metrics.get('Max Drawdown (%)', 0)
                    st.metric("ìµœëŒ€ ë‚™í­", f"{strategy_mdd:.2f}%",
                             f"{strategy_mdd - benchmark_mdd:+.2f}%p")

                with col3:
                    strategy_sharpe = strategy_metrics.get('Sharpe Ratio', 0)
                    benchmark_sharpe = benchmark_metrics.get('Sharpe Ratio', 0)
                    st.metric("ìƒ¤í”„ ë¹„ìœ¨", f"{strategy_sharpe:.3f}",
                             f"{strategy_sharpe - benchmark_sharpe:+.3f}")

                with col4:
                    strategy_return = strategy_metrics.get('Total Return (%)', 0)
                    benchmark_return = benchmark_metrics.get('Total Return (%)', 0)
                    st.metric("ì´ ìˆ˜ìµë¥ ", f"{strategy_return:.1f}%",
                             f"{strategy_return - benchmark_return:+.1f}%p")

                with col5:
                    strategy_vol = strategy_metrics.get('Volatility (%)', 0)
                    benchmark_vol = benchmark_metrics.get('Volatility (%)', 0)
                    st.metric("ë³€ë™ì„±", f"{strategy_vol:.1f}%",
                             f"{strategy_vol - benchmark_vol:+.1f}%p")

                # ì„±ê³¼ ì°¨íŠ¸
                st.header("ğŸ“ˆ ì„±ê³¼ ì°¨íŠ¸")
                perf_chart = create_performance_chart(strategy_df, benchmark_df, initial_capital)
                if perf_chart:
                    st.plotly_chart(perf_chart, use_container_width=True)

                # ì—°ê°„ ìˆ˜ìµë¥  ë¹„êµ
                if not strategy_annual.empty or not benchmark_annual.empty:
                    st.subheader("ğŸ“Š ì—°ê°„ ìˆ˜ìµë¥  ë¹„êµ")
                    col1, col2 = st.columns(2)
                    with col1:
                        annual_chart = create_annual_comparison_chart(strategy_annual, benchmark_annual)
                        if annual_chart:
                            st.plotly_chart(annual_chart, use_container_width=True)
                    with col2:
                        if not strategy_annual.empty and not benchmark_annual.empty:
                            comparison_df = pd.DataFrame({
                                'ì—°ë„': strategy_annual['Year'],
                                'ì „ëµ ìˆ˜ìµë¥  (%)': strategy_annual['Return_Pct'].round(1),
                                'ë²¤ì¹˜ë§ˆí¬ ìˆ˜ìµë¥  (%)': benchmark_annual['Return_Pct'].round(1),
                                'ì´ˆê³¼ ìˆ˜ìµë¥  (%p)': (strategy_annual['Return_Pct'] - benchmark_annual['Return_Pct']).round(1)
                            })
                            st.dataframe(comparison_df, use_container_width=True)

                # ì‹¤ì‹œê°„ ì‹ í˜¸
                st.header("ğŸ¯ ì‹¤ì‹œê°„ íˆ¬ì ì‹ í˜¸")
                if signals:
                    buy_signals = sum(1 for s in signals if s.momentum_signal)
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("ë¶„ì„ ê¸°ì¤€ì¼", end_date_ts.strftime('%Y-%m-%d'))
                    with col2:
                        st.metric("ë§¤ìˆ˜ ì‹ í˜¸", f"{buy_signals}/{len(signals)}ê°œ")
                    with col3:
                        signal_ratio = buy_signals / len(signals) * 100
                        st.metric("ì‹ í˜¸ ë¹„ìœ¨", f"{signal_ratio:.1f}%")

                    # ì‹ í˜¸ ìƒì„¸
                    signal_data = []
                    for s in signals:
                        signal_data.append({
                            'ìì‚°': s.asset_ticker,
                            'í˜„ì¬ê°€(ì§€í‘œ)': f"${s.indicator_price:.2f}",
                            f'SMA{s.sma_period if hasattr(s, "sma_period") else ""}': f"${s.sma_value:.2f}",
                            'ì‹ í˜¸': "ğŸŸ¢ ë§¤ìˆ˜" if s.momentum_signal else "ğŸ”´ í˜„ê¸ˆëŒ€ê¸°",
                            'ì‹ í˜¸ê°•ë„': f"{s.signal_strength:+.1f}%",
                            'ê¶Œì¥ë¹„ì¤‘': f"{s.recommended_weight*100:.1f}%"
                        })

                    signal_df = pd.DataFrame(signal_data)
                    st.dataframe(signal_df, use_container_width=True)

                    # ì‹ í˜¸ ì°¨íŠ¸
                    signals_chart = create_signals_chart(signals)
                    if signals_chart:
                        st.plotly_chart(signals_chart, use_container_width=True)

                # í¬íŠ¸í´ë¦¬ì˜¤ ê¶Œì¥ì‚¬í•­
                st.subheader("ğŸ’¼ ê¶Œì¥ í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±")
                if portfolio_weights:
                    portfolio_data = []
                    for asset, weight in sorted(portfolio_weights.items(),
                                                key=lambda x: x[1], reverse=True):
                        if weight > 0.001:
                            investment_amount = initial_capital * weight
                            portfolio_data.append({
                                'ìì‚°': asset,
                                'ê¶Œì¥ ë¹„ì¤‘': f"{weight*100:.1f}%",
                                'íˆ¬ì ê¸ˆì•¡': f"${investment_amount:,.0f}",
                                'ìƒíƒœ': "í˜„ê¸ˆ ëŒ€ê¸°" if asset == 'CASH' else "íˆ¬ì ëŒ€ìƒ"
                            })

                    portfolio_df = pd.DataFrame(portfolio_data)
                    st.dataframe(portfolio_df, use_container_width=True)

                # ìƒì„¸ ì„±ê³¼ í‘œ
                st.header("ğŸ“‹ ìƒì„¸ ì„±ê³¼ ë¶„ì„")
                col1, col2 = st.columns(2)
                with col1:
                    st.subheader("ë™ì ìì‚°ë°°ë¶„ ì „ëµ")
                    strategy_detail = pd.DataFrame([
                        {
                            'ì§€í‘œ': k,
                            'ê°’': (
                                f"{v:.3f}" if isinstance(v, (int, float)) and k != 'Final Value'
                                else f"${v:,.0f}" if k == 'Final Value'
                                else str(v)
                            )
                        }
                        for k, v in strategy_metrics.items()
                    ])  # â† ë¦¬ìŠ¤íŠ¸ ë° ê´„í˜¸ ë‹«ê¸°
                    st.dataframe(strategy_detail, use_container_width=True)

                with col2:
                    st.subheader("Buy & Hold ë²¤ì¹˜ë§ˆí¬")
                    benchmark_detail = pd.DataFrame([
                        {
                            'ì§€í‘œ': k,
                            'ê°’': (
                                f"{v:.3f}" if isinstance(v, (int, float)) and k != 'Final Value'
                                else f"${v:,.0f}" if k == 'Final Value'
                                else str(v)
                            )
                        }
                        for k, v in benchmark_metrics.items()
                    ])  # â† ë¦¬ìŠ¤íŠ¸ ë° pd.DataFrame ê´„í˜¸ë¥¼ ì •í™•íˆ ë‹«ìŒ
                    st.dataframe(benchmark_detail, use_container_width=True)

                # ë°ì´í„° ë‹¤ìš´ë¡œë“œ
                st.header("ğŸ’¾ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ")
                col1, col2, col3 = st.columns(3)
                with col1:
                    if not strategy_df.empty:
                        csv = strategy_df.to_csv()
                        st.download_button(
                            label="ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ íˆìŠ¤í† ë¦¬",
                            data=csv,
                            file_name=f"portfolio_history_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                with col2:
                    if signals:
                        signals_csv = signal_df.to_csv(index=False)
                        st.download_button(
                            label="ğŸ¯ ì‹¤ì‹œê°„ ì‹ í˜¸",
                            data=signals_csv,
                            file_name=f"live_signals_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                with col3:
                    if trade_log:
                        trade_df = pd.DataFrame(trade_log)
                        trade_csv = trade_df.to_csv(index=False)
                        st.download_button(
                            label="ğŸ“ˆ ê±°ë˜ ë‚´ì—­",
                            data=trade_csv,
                            file_name=f"trade_log_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )

    except Exception as e:
        st.error(f"âŒ ì•± ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        st.error("í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
        with st.expander("ìƒì„¸ ì˜¤ë¥˜ ì •ë³´"):
            st.code(traceback.format_exc())

if __name__ == "__main__":
    main()