# -*- coding: utf-8 -*-
"""동적자산배분백테스트 앱ver1.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QcNKfr9cFk6QJ20Whk18kBZWhbp2YGsv
"""

import streamlit as st
import pandas as pd
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from dataclasses import dataclass, field
from pandas.tseries.offsets import BusinessDay, MonthEnd, WeekOfMonth
from typing import List, Dict, Tuple, Optional, Union
import warnings
import io
import base64
from datetime import datetime, timedelta
import time
import traceback

warnings.filterwarnings('ignore')

# 페이지 설정
st.set_page_config(
    page_title="동적자산배분 백테스트 앱 ver1.0",
    page_icon="📊",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS 스타일링
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        color: #1f77b4;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
    .success-box {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .warning-box {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .info-box {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
        color: #0c5460;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 1rem 0;
    }
    .comparison-table {
        font-size: 0.9rem;
    }
</style>
""", unsafe_allow_html=True)

# 데이터 클래스 정의
@dataclass
class AssetConfig:
    asset_ticker: str
    weight_decimal: float
    original_weight_input: float
    indicator_ticker: str
    sma_period: int

    def __repr__(self):
        return (f"AssetConfig(자산='{self.asset_ticker}', 입력비율={self.original_weight_input:.1f}%, "
                f"최종적용비율={self.weight_decimal*100:.1f}%, "
                f"지표='{self.indicator_ticker}', MA기간={self.sma_period})")

@dataclass
class LiveSignal:
    date: pd.Timestamp
    asset_ticker: str
    current_price: float
    indicator_price: float
    sma_value: float
    momentum_signal: bool
    recommended_weight: float
    signal_strength: float

    def __repr__(self):
        signal_text = "🟢 매수" if self.momentum_signal else "🔴 현금대기"
        return (f"{self.asset_ticker}: {signal_text} | "
                f"현재가(지표): ${self.indicator_price:.2f} | "
                f"SMA: ${self.sma_value:.2f} | "
                f"권장비중: {self.recommended_weight*100:.1f}% | "
                f"신호강도: {self.signal_strength:+.1f}%")

# 유틸리티 함수들
@st.cache_data
def calculate_drawdown(cumulative_returns_series: pd.Series) -> pd.Series:
    """드로우다운 계산"""
    try:
        if cumulative_returns_series.empty or cumulative_returns_series.isnull().all():
            return pd.Series(dtype='float64', index=cumulative_returns_series.index)

        processed_series = cumulative_returns_series.ffill()
        if pd.isna(processed_series.iloc[0]):
            processed_series = processed_series.bfill()
        if processed_series.isnull().all():
            return pd.Series(dtype='float64', index=processed_series.index)

        peak = processed_series.cummax()
        peak = peak.replace(0, np.nan).ffill().bfill().fillna(1e-9)
        drawdown = (processed_series / peak) - 1
        return drawdown
    except Exception as e:
        st.error(f"드로우다운 계산 오류: {e}")
        return pd.Series(dtype='float64')

def validate_ticker(ticker: str) -> bool:
    """티커 유효성 검증"""
    if not ticker or len(ticker) < 1 or len(ticker) > 10:
        return False
    import re
    return bool(re.match(r'^[A-Z0-9.-]+$', ticker))

# 시장 데이터 제공자 클래스
class MarketDataProvider:
    def __init__(self, asset_configs: List[AssetConfig], start_date: str, end_date: str):
        self.asset_configs = asset_configs
        self.data_start_date = pd.to_datetime(start_date)
        self.data_end_date = pd.to_datetime(end_date)
        self.all_tickers = self._get_all_unique_tickers()
        self.raw_data = {}
        self.price_data = {}
        self.sma_data = {}
        self.failed_tickers = []

    def _get_all_unique_tickers(self) -> List[str]:
        tickers = set()
        for ac in self.asset_configs:
            if validate_ticker(ac.asset_ticker):
                tickers.add(ac.asset_ticker)
            if validate_ticker(ac.indicator_ticker):
                tickers.add(ac.indicator_ticker)
        return sorted(list(tickers))

    def _download_data(self, ticker: str, start_date: pd.Timestamp, end_date: pd.Timestamp) -> pd.DataFrame:
        """데이터 다운로드 (에러 처리 강화)"""
        try:
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    df = yf.download(
                        ticker,
                        start=start_date,
                        end=end_date,
                        progress=False,
                        auto_adjust=False,
                        timeout=30
                    )
                    if df.empty:
                        if attempt < max_retries - 1:
                            time.sleep(1)
                            continue
                        else:
                            return pd.DataFrame()

                    if isinstance(df.columns, pd.MultiIndex):
                        df.columns = df.columns.get_level_values(0)
                        df = df.loc[:, ~df.columns.duplicated(keep='first')]

                    if 'Adj Close' not in df.columns:
                        if 'Close' in df.columns:
                            df['Adj Close'] = df['Close']
                        else:
                            return pd.DataFrame()

                    for col in ['Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']:
                        if col in df.columns:
                            df[col] = pd.to_numeric(df[col], errors='coerce')

                    df_clean = df.dropna(subset=['Adj Close'])
                    if len(df_clean) < 10:
                        return pd.DataFrame()

                    return df_clean

                except Exception as retry_error:
                    if attempt < max_retries - 1:
                        time.sleep(2)
                        continue
                    else:
                        raise retry_error

        except Exception as e:
            st.warning(f"⚠️ {ticker} 데이터 다운로드 실패: {str(e)}")
            self.failed_tickers.append(ticker)
            return pd.DataFrame()

    def load_all_data(self):
        """모든 데이터 로드"""
        if not self.all_tickers:
            st.error("유효한 티커가 없습니다.")
            return False

        progress_bar = st.progress(0)
        status_text = st.empty()
        successful_downloads = 0

        for i, ticker in enumerate(self.all_tickers):
            status_text.text(f'📡 데이터 다운로드 중: {ticker} ({i+1}/{len(self.all_tickers)})')
            df = self._download_data(ticker, self.data_start_date, self.data_end_date)

            if not df.empty:
                self.raw_data[ticker] = df
                if 'Adj Close' in df.columns:
                    self.price_data[ticker] = df['Adj Close'].copy()
                    successful_downloads += 1
                    st.success(f"✅ {ticker}: {len(df)}개 데이터 포인트")
            else:
                st.warning(f"❌ {ticker}: 데이터 없음")

            progress_bar.progress((i + 1) / len(self.all_tickers))

        if successful_downloads == 0:
            st.error("모든 티커에서 데이터 다운로드에 실패했습니다.")
            return False

        status_text.text('📊 SMA 계산 중...')

        try:
            for ac in self.asset_configs:
                sma_key = (ac.indicator_ticker, ac.sma_period)
                if sma_key in self.sma_data:
                    continue

                if ac.indicator_ticker in self.price_data:
                    price_series = self.price_data[ac.indicator_ticker]
                    if len(price_series) >= ac.sma_period:
                        sma_series = price_series.rolling(
                            window=ac.sma_period,
                            min_periods=ac.sma_period
                        ).mean()
                        self.sma_data[sma_key] = sma_series
                    else:
                        st.warning(f"⚠️ {ac.indicator_ticker}: SMA {ac.sma_period}일 계산에 필요한 데이터 부족")
                        self.sma_data[sma_key] = pd.Series(dtype=float, index=price_series.index)
                else:
                    st.warning(f"⚠️ {ac.indicator_ticker}: 가격 데이터 없음")
                    self.sma_data[sma_key] = pd.Series(dtype=float)
        except Exception as e:
            st.error(f"SMA 계산 오류: {e}")
            return False

        progress_bar.empty()
        status_text.empty()

        if self.failed_tickers:
            st.warning(f"⚠️ 다운로드 실패 티커: {', '.join(self.failed_tickers)}")

        st.success(f"✅ 총 {successful_downloads}/{len(self.all_tickers)}개 티커 데이터 로드 완료")
        return successful_downloads > 0

    def get_price_on_date(self, ticker: str, date: pd.Timestamp) -> Optional[float]:
        try:
            if ticker in self.price_data:
                series = self.price_data[ticker]
                if date in series.index:
                    price = series.loc[date]
                else:
                    price = series.asof(date)
                return float(price) if pd.notna(price) else None
            return None
        except Exception:
            return None

    def get_sma_on_date(self, indicator_ticker: str, sma_period: int, date: pd.Timestamp) -> Optional[float]:
        try:
            sma_key = (indicator_ticker, sma_period)
            if sma_key in self.sma_data:
                series = self.sma_data[sma_key]
                if series.empty:
                    return None
                if date in series.index:
                    sma_value = series.loc[date]
                else:
                    sma_value = series.asof(date)
                return float(sma_value) if pd.notna(sma_value) else None
            return None
        except Exception:
            return None

    def get_return_for_period(self, ticker: str, start_date: pd.Timestamp, end_date: pd.Timestamp) -> float:
        try:
            price_start = self.get_price_on_date(ticker, start_date)
            price_end = self.get_price_on_date(ticker, end_date)
            if price_start is not None and price_end is not None and price_start != 0:
                return (price_end / price_start) - 1
            return 0.0
        except Exception:
            return 0.0

# 포트폴리오 클래스
class Portfolio:
    def __init__(self, initial_capital: float):
        self.initial_capital = float(initial_capital)
        self.current_value = float(initial_capital)
        self.weights = {'CASH': 1.0}
        self.history = []

    def get_current_cash_value(self) -> float:
        return self.current_value * self.weights.get('CASH', 0.0)

    def record_state(self, date: pd.Timestamp, action_notes: str = ""):
        self.history.append({
            'date': date,
            'portfolio_value': round(self.current_value, 2),
            'weights': {k: round(v, 4) for k, v in self.weights.items() if abs(v) > 1e-6},
            'cash_value': round(self.get_current_cash_value(), 2),
            'notes': action_notes
        })

    def update_value_from_period_returns(self, period_asset_returns: Dict[str, float]):
        if not self.weights:
            return

        portfolio_period_return = 0.0
        for asset_ticker, weight in self.weights.items():
            asset_return = period_asset_returns.get(asset_ticker, 0.0)
            if pd.isna(asset_return):
                asset_return = 0.0
            portfolio_period_return += weight * asset_return

        self.current_value *= (1 + portfolio_period_return)

    def rebalance_to_target_weights(self, target_weights: Dict[str, float],
                                   transaction_cost_rate: float, slippage_rate: float) -> float:
        total_weight_change = 0.0
        all_assets = set(self.weights.keys()) | set(target_weights.keys())

        for asset_ticker in all_assets:
            current_w = self.weights.get(asset_ticker, 0.0)
            target_w = target_weights.get(asset_ticker, 0.0)
            total_weight_change += abs(target_w - current_w)

        traded_portion = total_weight_change / 2.0
        costs = self.current_value * traded_portion * (transaction_cost_rate + slippage_rate)

        self.current_value -= costs
        if self.current_value < 0:
            self.current_value = 0.0

        self.weights = {k: v for k, v in target_weights.items() if abs(v) > 1e-6}
        current_sum_weights = sum(self.weights.values())
        if abs(current_sum_weights - 1.0) > 1e-6 and current_sum_weights > 0:
            for k in self.weights:
                self.weights[k] /= current_sum_weights

        return costs

    def apply_cash_flow(self, amount: float):
        """
        매월말에 사용자가 입력한 납입 또는 인출 금액을 현재 포트폴리오 가치에 반영.
        amount > 0 이면 납입(입금), amount < 0 이면 인출(출금).
        """
        self.current_value += amount
        # 음수가 되지 않도록 최소 0으로 처리
        if self.current_value < 0:
            self.current_value = 0.0

# 백테스터 클래스
class Backtester:
    def __init__(self, asset_configs: List[AssetConfig], backtest_params: Dict,
                 market_data_provider: MarketDataProvider):
        self.asset_configs = asset_configs
        self.params = backtest_params
        self.dataprovider = market_data_provider
        self.portfolio = Portfolio(self.params['initial_capital'])
        self.benchmark_portfolio = Portfolio(self.params['initial_capital'])
        self._setup_initial_benchmark_weights()
        self.rebalancing_dates = self._generate_rebalancing_dates()
        self.trade_log = []
        # 현금 흐름 관련 파라미터
        self.cashflow_enabled = self.params.get('cashflow_enabled', False)
        self.cashflow_amount = self.params.get('cashflow_amount', 0.0)
        self.cashflow_type = self.params.get('cashflow_type', '납입')  # '납입' 또는 '인출'

    def _generate_rebalancing_dates(self) -> pd.DatetimeIndex:
        try:
            if not self.asset_configs:
                return pd.DatetimeIndex([])

            ref_ticker = self.asset_configs[0].indicator_ticker
            if ref_ticker not in self.dataprovider.price_data:
                st.warning(f"기준 티커 {ref_ticker} 데이터가 없습니다.")
                return pd.DatetimeIndex([])

            reference_index = self.dataprovider.price_data[ref_ticker].index.sort_values().unique()
            temp_series = pd.Series(data=1, index=reference_index)

            backtest_start = pd.to_datetime(self.params['start_date'])
            backtest_end = pd.to_datetime(self.params['end_date'])
            freq = self.params['frequency']

            if freq == 'M':
                candidate_dates = temp_series.resample('BME').last().index
            elif freq == 'W-FRI':
                candidate_dates = temp_series.resample('W-FRI').last().index
            else:
                candidate_dates = temp_series.resample('BME').last().index

            adjusted_dates = []
            for date_candidate in candidate_dates:
                actual_date = date_candidate
                if actual_date not in reference_index:
                    future_dates = reference_index[reference_index > date_candidate]
                    if not future_dates.empty:
                        actual_date = future_dates[0]
                    else:
                        continue

                if backtest_start <= actual_date <= backtest_end:
                    adjusted_dates.append(actual_date)

            return pd.DatetimeIndex(sorted(list(set(adjusted_dates)))).unique()

        except Exception as e:
            st.error(f"리밸런싱 날짜 생성 오류: {e}")
            return pd.DatetimeIndex([])

    def _get_momentum_decision(self, asset_config: AssetConfig, date: pd.Timestamp) -> bool:
        """
        모멘텀 결정을 위해 지표 자산의 가격과 지표 자산의 SMA를 비교하도록 수정.
        """
        try:
            # 지표 자산의 가격을 가져옴
            indicator_price = self.dataprovider.get_price_on_date(asset_config.indicator_ticker, date)
            sma = self.dataprovider.get_sma_on_date(asset_config.indicator_ticker,
                                                   asset_config.sma_period, date)
            if indicator_price is None or sma is None:
                return False
            return indicator_price > sma
        except Exception:
            return False

    def _calculate_target_weights(self, momentum_assets: List[AssetConfig]) -> Dict[str, float]:
        target_weights = {}
        method = self.params['rebalancing_method']

        if not momentum_assets:
            target_weights['CASH'] = 1.0
            return target_weights

        if method == 'A':
            sum_weights = sum(ac.original_weight_input for ac in momentum_assets)
            if abs(sum_weights) < 1e-9:
                target_weights['CASH'] = 1.0
                return target_weights
            for ac in momentum_assets:
                target_weights[ac.asset_ticker] = ac.original_weight_input / sum_weights
        elif method == 'B':
            total_weight = 0.0
            for ac in momentum_assets:
                target_weights[ac.asset_ticker] = ac.weight_decimal
                total_weight += ac.weight_decimal
            cash_weight = 1.0 - total_weight
            if cash_weight > 1e-6:
                target_weights['CASH'] = max(0, cash_weight)

        return {k: v for k, v in target_weights.items() if abs(v) > 1e-6}

    def _setup_initial_benchmark_weights(self):
        initial_weights = {ac.asset_ticker: ac.weight_decimal for ac in self.asset_configs}
        cash_w = 1.0 - sum(initial_weights.values())
        if cash_w > 1e-6:
            initial_weights['CASH'] = cash_w
        self.benchmark_portfolio.weights = initial_weights.copy()

    def run_backtest(self):
        try:
            if self.rebalancing_dates.empty:
                st.error("리밸런싱 날짜가 없습니다.")
                return [], [], []

            first_date = self.rebalancing_dates[0]
            self.portfolio.record_state(first_date, "Initial State")
            self.benchmark_portfolio.record_state(first_date, "Initial Benchmark State")

            progress_bar = st.progress(0)
            status_text = st.empty()

            for i, current_date in enumerate(self.rebalancing_dates):
                status_text.text(f'⚙️ 백테스트 진행: {current_date.strftime("%Y-%m-%d")} ({i+1}/{len(self.rebalancing_dates)})')

                prev_date = self.portfolio.history[-1]['date']

                if current_date > prev_date:
                    # 1) 전략 포트폴리오 가치 업데이트 (수익률 반영)
                    strategy_returns = {
                        asset: (0.0 if asset == 'CASH' else
                               self.dataprovider.get_return_for_period(asset, prev_date, current_date))
                        for asset in self.portfolio.weights.keys()
                    }
                    self.portfolio.update_value_from_period_returns(strategy_returns)

                    # ② 현금 흐름 적용 (월말 리밸런싱 때만 실행)
                    if self.cashflow_enabled and self.params['frequency'] == 'M':
                        # cashflow_type이 '납입'이면 +amount, '인출'이면 -amount
                        cf_amount = self.cashflow_amount if self.cashflow_type == '납입' else -self.cashflow_amount
                        self.portfolio.apply_cash_flow(cf_amount)

                    # ③ 벤치마크는 현금 흐름 적용 없이 수익률만 반영
                    benchmark_returns = {
                        asset: (0.0 if asset == 'CASH' else
                               self.dataprovider.get_return_for_period(asset, prev_date, current_date))
                        for asset in self.benchmark_portfolio.weights.keys()
                    }
                    self.benchmark_portfolio.update_value_from_period_returns(benchmark_returns)

                # ④ 모멘텀 신호 확인 및 리밸런싱
                momentum_assets = [
                    ac for ac in self.asset_configs
                    if self._get_momentum_decision(ac, current_date)
                ]
                target_weights = self._calculate_target_weights(momentum_assets)

                value_before = self.portfolio.current_value
                costs = self.portfolio.rebalance_to_target_weights(
                    target_weights,
                    self.params['transaction_cost_rate'],
                    self.params['slippage_rate']
                )

                self.trade_log.append({
                    'date': current_date,
                    'target_weights': {
                        k: round(v, 4)
                        for k, v in target_weights.items() if abs(v) > 1e-6
                    },
                    'portfolio_value_before_costs': round(value_before, 2),
                    'transaction_costs': round(costs, 2),
                    'portfolio_value_after_costs': round(self.portfolio.current_value, 2)
                })

                self.portfolio.record_state(current_date, "Rebalanced")
                self.benchmark_portfolio.record_state(current_date, "Benchmark Update")

                progress_bar.progress((i + 1) / len(self.rebalancing_dates))

            progress_bar.empty()
            status_text.empty()

            return self.portfolio.history, self.benchmark_portfolio.history, self.trade_log

        except Exception as e:
            st.error(f"백테스트 실행 오류: {e}")
            return [], [], []

# 실시간 신호 생성기
class LiveSignalGenerator:
    def __init__(self, asset_configs: List[AssetConfig], dataprovider: MarketDataProvider):
        self.asset_configs = asset_configs
        self.dataprovider = dataprovider

    def generate_signals(self, target_date: pd.Timestamp, method: str = 'A') -> Tuple[List[LiveSignal], Dict[str, float]]:
        signals = []
        momentum_assets = []

        for config in self.asset_configs:
            # 지표 자산의 가격을 가져옴
            indicator_price = self.dataprovider.get_price_on_date(config.indicator_ticker, target_date)
            sma_value = self.dataprovider.get_sma_on_date(config.indicator_ticker,
                                                        config.sma_period, target_date)

            if indicator_price is None or sma_value is None:
                continue

            # 지표 자산 가격과 SMA를 비교
            momentum_signal = indicator_price > sma_value
            # 신호 강도 계산도 지표 자산 가격 기준으로 수정
            signal_strength = ((indicator_price / sma_value) - 1) * 100

            # LiveSignal에 asset_ticker는 그대로, current_price에는 지표 가격을 표시
            signal = LiveSignal(
                date=target_date,
                asset_ticker=config.asset_ticker,
                current_price=indicator_price,
                indicator_price=indicator_price,
                sma_value=sma_value,
                momentum_signal=momentum_signal,
                recommended_weight=0.0,
                signal_strength=signal_strength
            )

            signals.append(signal)
            if momentum_signal:
                momentum_assets.append(config)

        # 포트폴리오 비중 계산
        portfolio_weights = self._calculate_portfolio_weights(momentum_assets, method)

        # 신호에 권장 비중 업데이트
        for signal in signals:
            signal.recommended_weight = portfolio_weights.get(signal.asset_ticker, 0.0)

        return signals, portfolio_weights

    def _calculate_portfolio_weights(self, momentum_assets: List[AssetConfig], method: str) -> Dict[str, float]:
        weights = {}

        if not momentum_assets:
            weights['CASH'] = 1.0
            return weights

        if method == 'A':
            total_weight = sum(ac.original_weight_input for ac in momentum_assets)
            if total_weight > 0:
                for ac in momentum_assets:
                    weights[ac.asset_ticker] = ac.original_weight_input / total_weight
            else:
                weights['CASH'] = 1.0
        elif method == 'B':
            total_weight = 0.0
            for ac in momentum_assets:
                weights[ac.asset_ticker] = ac.weight_decimal
                total_weight += ac.weight_decimal

            cash_weight = 1.0 - total_weight
            if cash_weight > 0:
                weights['CASH'] = cash_weight

        return weights

# 분석 함수들
def history_to_df(history_list: List[Dict]) -> pd.DataFrame:
    if not history_list:
        return pd.DataFrame()
    df = pd.DataFrame(history_list)
    df['date'] = pd.to_datetime(df['date'])
    return df.set_index('date').sort_index()

def calculate_annual_returns(portfolio_df: pd.DataFrame, initial_capital: float) -> pd.DataFrame:
    """연간 수익률 계산"""
    try:
        if portfolio_df.empty or 'portfolio_value' not in portfolio_df.columns:
            return pd.DataFrame()

        annual_values = portfolio_df['portfolio_value'].resample('Y').last()
        annual_returns = []
        prev_value = initial_capital

        for year, end_value in annual_values.items():
            if pd.isna(end_value):
                continue

            year_return = (end_value / prev_value - 1) * 100
            annual_returns.append({
                'Year': year.year,
                'Start_Value': prev_value,
                'End_Value': end_value,
                'Return_Pct': year_return,
                'Profit_Loss': end_value - prev_value
            })
            prev_value = end_value

        return pd.DataFrame(annual_returns)

    except Exception as e:
        st.error(f"연간 수익률 계산 오류: {e}")
        return pd.DataFrame()

def calculate_performance_metrics(portfolio_df: pd.DataFrame, params: Dict) -> Dict:
    """성과 지표 계산"""
    try:
        if portfolio_df.empty or 'portfolio_value' not in portfolio_df.columns:
            return {}

        start_value = params['initial_capital']
        end_value = portfolio_df['portfolio_value'].iloc[-1]
        start_date = portfolio_df.index[0]
        end_date = portfolio_df.index[-1]
        years = (end_date - start_date).days / 365.25

        if years > 0 and start_value > 0:
            cagr = (end_value / start_value) ** (1 / years) - 1
        else:
            cagr = 0

        returns = portfolio_df['portfolio_value'].pct_change().dropna()
        total_return = (end_value / start_value - 1) * 100

        if len(returns) > 1:
            volatility = returns.std() * np.sqrt(252) * 100
            risk_free_rate = params.get('risk_free_rate', 0.02)
            if volatility > 0:
                sharpe = (cagr - risk_free_rate) / (volatility / 100)
            else:
                sharpe = 0
        else:
            volatility = 0
            sharpe = 0

        cumulative = portfolio_df['portfolio_value'] / start_value
        drawdown = calculate_drawdown(cumulative)
        max_dd = drawdown.min() * 100 if not drawdown.empty else 0

        if len(returns) > 0:
            win_rate = (returns > 0).sum() / len(returns) * 100
        else:
            win_rate = 0

        return {
            'CAGR (%)': cagr * 100,
            'Total Return (%)': total_return,
            'Volatility (%)': volatility,
            'Sharpe Ratio': sharpe,
            'Max Drawdown (%)': max_dd,
            'Win Rate (%)': win_rate,
            'Final Value': end_value,
            'Profit/Loss': end_value - start_value
        }

    except Exception as e:
        st.error(f"성과 지표 계산 오류: {e}")
        return {}

# 시각화 함수들
def create_performance_chart(strategy_df: pd.DataFrame, benchmark_df: pd.DataFrame, initial_capital: float):
    """성과 차트 생성 (수익률 + MDD)"""
    try:
        fig = make_subplots(
            rows=2, cols=1,
            subplot_titles=('📈 누적 수익률 비교', '📉 최대 드로우다운 (MDD)'),
            vertical_spacing=0.12,
            row_heights=[0.65, 0.35],
            specs=[[{"secondary_y": False}], [{"secondary_y": False}]]
        )

        if not strategy_df.empty and 'portfolio_value' in strategy_df.columns:
            strategy_cum = strategy_df['portfolio_value'] / initial_capital
            fig.add_trace(
                go.Scatter(
                    x=strategy_df.index,
                    y=strategy_cum,
                    name='동적자산배분 전략',
                    line=dict(color='#1f77b4', width=3),
                    hovertemplate='날짜: %{x}<br>수익률 배수: %{y:.3f}<extra></extra>'
                ),
                row=1, col=1
            )

        if not benchmark_df.empty and 'portfolio_value' in benchmark_df.columns:
            benchmark_cum = benchmark_df['portfolio_value'] / initial_capital
            fig.add_trace(
                go.Scatter(
                    x=benchmark_df.index,
                    y=benchmark_cum,
                    name='Buy & Hold 벤치마크',
                    line=dict(color='#ff7f0e', width=2, dash='dash'),
                    hovertemplate='날짜: %{x}<br>수익률 배수: %{y:.3f}<extra></extra>'
                ),
                row=1, col=1
            )

        if not strategy_df.empty:
            strategy_dd = calculate_drawdown(strategy_cum) * 100
            fig.add_trace(
                go.Scatter(
                    x=strategy_df.index,
                    y=strategy_dd,
                    name='전략 MDD',
                    fill='tonexty',
                    fillcolor='rgba(255, 0, 0, 0.2)',
                    line=dict(color='red', width=2),
                    hovertemplate='날짜: %{x}<br>드로우다운: %{y:.2f}%<extra></extra>'
                ),
                row=2, col=1
            )

        if not benchmark_df.empty:
            benchmark_dd = calculate_drawdown(benchmark_cum) * 100
            fig.add_trace(
                go.Scatter(
                    x=benchmark_df.index,
                    y=benchmark_dd,
                    name='벤치마크 MDD',
                    line=dict(color='orange', width=2, dash='dot'),
                    hovertemplate='날짜: %{x}<br>드로우다운: %{y:.2f}%<extra></extra>'
                ),
                row=2, col=1
            )

        fig.update_layout(
            height=700,
            showlegend=True,
            title=dict(
                text="<b>동적자산배분 vs Buy & Hold 성과 비교</b>",
                x=0.5,
                font=dict(size=16)
            ),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )

        fig.update_yaxes(title_text="누적 수익률 (배수)", row=1, col=1)
        fig.update_yaxes(title_text="드로우다운 (%)", row=2, col=1)
        fig.update_xaxes(title_text="날짜", row=2, col=1)
        fig.add_hline(y=0, line_dash="dash", line_color="black", row=2, col=1)

        return fig

    except Exception as e:
        st.error(f"성과 차트 생성 오류: {e}")
        return None

def create_signals_chart(signals: List[LiveSignal]):
    """신호 차트 생성"""
    try:
        if not signals:
            return None

        fig = go.Figure()

        assets = [s.asset_ticker for s in signals]
        colors = ['#00cc44' if s.momentum_signal else '#ff4444' for s in signals]
        strengths = [s.signal_strength for s in signals]

        fig.add_trace(go.Bar(
            x=assets,
            y=strengths,
            marker_color=colors,
            text=[f"{s:+.1f}%" for s in strengths],
            textposition='auto',
            hovertemplate='자산: %{x}<br>신호 강도: %{y:.1f}%<extra></extra>'
        ))

        fig.update_layout(
            title="<b>📊 자산별 모멘텀 신호 강도</b>",
            xaxis_title="자산",
            yaxis_title="신호 강도 (%)",
            yaxis=dict(tickformat='.1f'),
            height=400,
            showlegend=False
        )

        fig.add_hline(y=0, line_dash="dash", line_color="black")

        return fig

    except Exception as e:
        st.error(f"신호 차트 생성 오류: {e}")
        return None

def create_annual_comparison_chart(strategy_annual: pd.DataFrame, benchmark_annual: pd.DataFrame):
    """연간 수익률 비교 차트"""
    try:
        if strategy_annual.empty and benchmark_annual.empty:
            return None

        fig = go.Figure()

        if not strategy_annual.empty:
            fig.add_trace(go.Bar(
                x=strategy_annual['Year'],
                y=strategy_annual['Return_Pct'],
                name='동적자산배분 전략',
                marker_color='#1f77b4',
                hovertemplate='연도: %{x}<br>수익률: %{y:.1f}%<extra></extra>'
            ))

        if not benchmark_annual.empty:
            fig.add_trace(go.Bar(
                x=benchmark_annual['Year'],
                y=benchmark_annual['Return_Pct'],
                name='Buy & Hold 벤치마크',
                marker_color='#ff7f0e',
                hovertemplate='연도: %{x}<br>수익률: %{y:.1f}%<extra></extra>'
            ))

        fig.update_layout(
            title="<b>📊 연간 수익률 비교</b>",
            xaxis_title="연도",
            yaxis_title="수익률 (%)",
            height=400,
            barmode='group'
        )

        fig.add_hline(y=0, line_dash="dash", line_color="black")

        return fig

    except Exception as e:
        st.error(f"연간 비교 차트 생성 오류: {e}")
        return None

# 메인 앱
def main():
    try:
        st.markdown('<h1 class="main-header">📊 동적자산배분 백테스트 앱 ver1.0</h1>', unsafe_allow_html=True)

        st.markdown("""
        <div class="info-box">
        <h4>🎯 모멘텀 기반 동적자산배분 전략</h4>
        <p>이동평균을 활용한 동적 자산배분 전략의 백테스트와 실시간 투자 신호를 제공합니다.</p>
        <p><strong>주요 특징:</strong> Buy & Hold 대비 성과 분석, MDD 관리, 실시간 신호 생성</p>
        </div>
        """, unsafe_allow_html=True)

        # 사이드바 - 입력 패널
        with st.sidebar:
            st.header("📋 전략 설정")

            # 1) 포트폴리오 구성
            st.subheader("1. 포트폴리오 구성")
            if 'asset_configs' not in st.session_state:
                st.session_state.asset_configs = []

            with st.expander("자산 추가", expanded=True):
                with st.form("add_asset"):
                    col1, col2 = st.columns(2)
                    with col1:
                        asset_ticker = st.text_input("자산 티커", placeholder="예: SPY").upper().strip()
                        weight = st.number_input("투자 비율 (%)", min_value=0.0, max_value=100.0, value=25.0)
                    with col2:
                        indicator_ticker = st.text_input("지표 티커", placeholder="예: SPY").upper().strip()
                        sma_period = st.number_input("SMA 기간", min_value=5, max_value=500, value=200)

                    add_asset = st.form_submit_button("자산 추가")
                    if add_asset:
                        if not asset_ticker:
                            st.error("자산 티커를 입력해주세요.")
                        elif not validate_ticker(asset_ticker):
                            st.error("올바른 티커 형식이 아닙니다.")
                        else:
                            if not indicator_ticker:
                                indicator_ticker = asset_ticker

                            new_config = AssetConfig(
                                asset_ticker=asset_ticker,
                                weight_decimal=weight/100.0,
                                original_weight_input=weight,
                                indicator_ticker=indicator_ticker,
                                sma_period=sma_period
                            )
                            st.session_state.asset_configs.append(new_config)
                            st.success(f"✅ {asset_ticker} 추가됨!")
                            st.rerun()

            if st.session_state.asset_configs:
                st.subheader("현재 포트폴리오")
                total_weight = sum(ac.original_weight_input for ac in st.session_state.asset_configs)
                for i, config in enumerate(st.session_state.asset_configs):
                    col1, col2 = st.columns([3, 1])
                    with col1:
                        st.text(f"{config.asset_ticker}: {config.original_weight_input:.1f}%")
                    with col2:
                        if st.button("❌", key=f"del_{i}", help="삭제"):
                            st.session_state.asset_configs.pop(i)
                            st.rerun()

                if abs(total_weight - 100.0) > 0.1:
                    st.warning(f"⚠️ 총 비율: {total_weight:.1f}%")
                    if st.button("🔄 100%로 정규화", use_container_width=True):
                        for config in st.session_state.asset_configs:
                            config.weight_decimal = config.original_weight_input / total_weight
                        st.success("✅ 정규화 완료!")
                        st.rerun()
                else:
                    st.success(f"✅ 총 비율: {total_weight:.1f}%")

            # 2) 백테스트 설정
            st.subheader("2. 백테스트 설정")
            col1, col2 = st.columns(2)
            with col1:
                start_year = st.selectbox("시작 연도", range(2000, 2025), index=20)
                start_month = st.selectbox("시작 월", range(1, 13), index=0)
            with col2:
                use_today = st.checkbox("오늘까지 분석", value=True)
                if not use_today:
                    end_year = st.selectbox("종료 연도", range(2000, 2026), index=24)
                    end_month = st.selectbox("종료 월", range(1, 13), index=11)

            frequency = st.selectbox("리밸런싱 빈도", ["월말 (M)", "주간 금요일 (W)"], index=0)
            method = st.selectbox("리밸런싱 방법",
                                  ["상대적 비율 유지", "고정 비율 + 현금"], index=0)

            # 3) 거래 비용
            st.subheader("3. 거래 비용")
            col1, col2 = st.columns(2)
            with col1:
                slippage = st.number_input("슬리피지 (%)", min_value=0.0, max_value=1.0, value=0.05, step=0.01)
                transaction_cost = st.number_input("거래 수수료 (%)", min_value=0.0, max_value=1.0, value=0.05, step=0.01)
            with col2:
                initial_capital = st.number_input("초기 자본 ($)", min_value=1000, value=10000, step=1000)
                risk_free_rate = st.number_input("무위험 이자율 (%)", min_value=0.0, max_value=10.0, value=2.0, step=0.1)

            # 4) 월별 현금 흐름 설정
            st.subheader("4. 월별 현금 흐름 설정")
            cashflow_enabled = st.checkbox("월별 현금 흐름 사용")
            if cashflow_enabled:
                cashflow_type = st.selectbox("유형", ["납입", "인출"], index=0)
                cashflow_amount = st.number_input("금액 ($)", min_value=0.0, value=100.0, step=10.0)
            else:
                cashflow_type = "납입"
                cashflow_amount = 0.0

        # 자산이 하나도 없으면 백테스트 불가
        if not st.session_state.asset_configs:
            st.warning("⚠️ 포트폴리오 구성을 위해 사이드바에서 자산을 추가해주세요.")
            st.subheader("💡 샘플 포트폴리오")
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("🏛️ 안정형", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("SPY", 0.6, 60.0, "SPY", 200),
                        AssetConfig("TLT", 0.4, 40.0, "TLT", 200)
                    ]
                    st.rerun()
            with col2:
                if st.button("⚖️ 균형형", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("SPY", 0.4, 40.0, "SPY", 200),
                        AssetConfig("QQQ", 0.3, 30.0, "QQQ", 200),
                        AssetConfig("VEA", 0.3, 30.0, "VEA", 200)
                    ]
                    st.rerun()
            with col3:
                if st.button("🚀 공격형", use_container_width=True):
                    st.session_state.asset_configs = [
                        AssetConfig("QQQ", 0.5, 50.0, "QQQ", 200),
                        AssetConfig("SPY", 0.3, 30.0, "SPY", 200),
                        AssetConfig("IWM", 0.2, 20.0, "IWM", 200)
                    ]
                    st.rerun()
            return

        # 분석 시작 버튼
        if st.button("🚀 백테스트 시작", type="primary", use_container_width=True):
            with st.spinner("분석을 시작합니다..."):
                # 1) 날짜 파라미터 구성
                start_date = f"{start_year}-{start_month:02d}-01"
                if use_today:
                    end_date = datetime.now().strftime('%Y-%m-%d')
                else:
                    end_date = f"{end_year}-{end_month:02d}-{pd.Period(f'{end_year}-{end_month}').days_in_month:02d}"

                backtest_params = {
                    'start_date': start_date,
                    'end_date': end_date,
                    'frequency': 'M' if frequency.startswith('월말') else 'W-FRI',
                    'rebalancing_method': 'A' if method.startswith('상대적') else 'B',
                    'slippage_rate': slippage / 100.0,
                    'transaction_cost_rate': transaction_cost / 100.0,
                    'initial_capital': initial_capital,
                    'risk_free_rate': risk_free_rate / 100.0,
                    'cashflow_enabled': cashflow_enabled,
                    'cashflow_type': cashflow_type,
                    'cashflow_amount': cashflow_amount
                }

                # 2) 데이터 버퍼 계산
                max_sma = max(ac.sma_period for ac in st.session_state.asset_configs)
                buffer_days = int(max_sma * 1.5 + 60)
                data_start = (pd.to_datetime(start_date) - pd.Timedelta(days=buffer_days)).strftime('%Y-%m-%d')

                # 3) 데이터 로드
                dataprovider = MarketDataProvider(
                    st.session_state.asset_configs,
                    data_start,
                    end_date
                )
                success = dataprovider.load_all_data()
                if not success:
                    st.error("❌ 데이터 로드에 실패했습니다. 티커를 확인해주세요.")
                    return

                # 4) 백테스트 실행
                backtester = Backtester(
                    st.session_state.asset_configs,
                    backtest_params,
                    dataprovider
                )
                strategy_history, benchmark_history, trade_log = backtester.run_backtest()
                if not strategy_history:
                    st.error("❌ 백테스트 실행에 실패했습니다.")
                    return

                # 5) 실시간 신호 생성
                signal_generator = LiveSignalGenerator(
                    st.session_state.asset_configs,
                    dataprovider
                )
                end_date_ts = pd.to_datetime(end_date)
                signals, portfolio_weights = signal_generator.generate_signals(
                    end_date_ts,
                    backtest_params['rebalancing_method']
                )

                # 6) 결과 분석
                strategy_df = history_to_df(strategy_history)
                benchmark_df = history_to_df(benchmark_history)

                strategy_metrics = calculate_performance_metrics(strategy_df, backtest_params)
                benchmark_metrics = calculate_performance_metrics(benchmark_df, backtest_params)

                strategy_annual = calculate_annual_returns(strategy_df, initial_capital)
                benchmark_annual = calculate_annual_returns(benchmark_df, initial_capital)

                # 7) 결과 표시
                st.success("✅ 백테스트 완료!")

                # **현금 흐름 사용 안내**
                if cashflow_enabled:
                    st.warning(
                        "⚠️ 현금 흐름 기능이 활성화되어 있습니다. "
                        "CAGR 및 총 수익률 등의 비율 지표는 외부 현금 유입/유출의 영향을 받아 왜곡될 수 있습니다. "
                        "최종 자산 가치는 정확히 계산되었습니다."
                    )

                # 핵심 성과 지표
                st.header("📊 핵심 성과 지표")

                col1, col2, col3, col4, col5 = st.columns(5)

                with col1:
                    strategy_cagr = strategy_metrics.get('CAGR (%)', 0)
                    benchmark_cagr = benchmark_metrics.get('CAGR (%)', 0)
                    st.metric("전략 CAGR", f"{strategy_cagr:.2f}%",
                             f"{strategy_cagr - benchmark_cagr:+.2f}%p")

                with col2:
                    strategy_mdd = strategy_metrics.get('Max Drawdown (%)', 0)
                    benchmark_mdd = benchmark_metrics.get('Max Drawdown (%)', 0)
                    st.metric("최대 낙폭", f"{strategy_mdd:.2f}%",
                             f"{strategy_mdd - benchmark_mdd:+.2f}%p")

                with col3:
                    strategy_sharpe = strategy_metrics.get('Sharpe Ratio', 0)
                    benchmark_sharpe = benchmark_metrics.get('Sharpe Ratio', 0)
                    st.metric("샤프 비율", f"{strategy_sharpe:.3f}",
                             f"{strategy_sharpe - benchmark_sharpe:+.3f}")

                with col4:
                    strategy_return = strategy_metrics.get('Total Return (%)', 0)
                    benchmark_return = benchmark_metrics.get('Total Return (%)', 0)
                    st.metric("총 수익률", f"{strategy_return:.1f}%",
                             f"{strategy_return - benchmark_return:+.1f}%p")

                with col5:
                    strategy_vol = strategy_metrics.get('Volatility (%)', 0)
                    benchmark_vol = benchmark_metrics.get('Volatility (%)', 0)
                    st.metric("변동성", f"{strategy_vol:.1f}%",
                             f"{strategy_vol - benchmark_vol:+.1f}%p")

                # 성과 차트
                st.header("📈 성과 차트")
                perf_chart = create_performance_chart(strategy_df, benchmark_df, initial_capital)
                if perf_chart:
                    st.plotly_chart(perf_chart, use_container_width=True)

                # 연간 수익률 비교
                if not strategy_annual.empty or not benchmark_annual.empty:
                    st.subheader("📊 연간 수익률 비교")
                    col1, col2 = st.columns(2)
                    with col1:
                        annual_chart = create_annual_comparison_chart(strategy_annual, benchmark_annual)
                        if annual_chart:
                            st.plotly_chart(annual_chart, use_container_width=True)
                    with col2:
                        if not strategy_annual.empty and not benchmark_annual.empty:
                            comparison_df = pd.DataFrame({
                                '연도': strategy_annual['Year'],
                                '전략 수익률 (%)': strategy_annual['Return_Pct'].round(1),
                                '벤치마크 수익률 (%)': benchmark_annual['Return_Pct'].round(1),
                                '초과 수익률 (%p)': (strategy_annual['Return_Pct'] - benchmark_annual['Return_Pct']).round(1)
                            })
                            st.dataframe(comparison_df, use_container_width=True)

                # 실시간 신호
                st.header("🎯 실시간 투자 신호")
                if signals:
                    buy_signals = sum(1 for s in signals if s.momentum_signal)
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("분석 기준일", end_date_ts.strftime('%Y-%m-%d'))
                    with col2:
                        st.metric("매수 신호", f"{buy_signals}/{len(signals)}개")
                    with col3:
                        signal_ratio = buy_signals / len(signals) * 100
                        st.metric("신호 비율", f"{signal_ratio:.1f}%")

                    # 신호 상세
                    signal_data = []
                    for s in signals:
                        signal_data.append({
                            '자산': s.asset_ticker,
                            '현재가(지표)': f"${s.indicator_price:.2f}",
                            f'SMA{s.sma_period if hasattr(s, "sma_period") else ""}': f"${s.sma_value:.2f}",
                            '신호': "🟢 매수" if s.momentum_signal else "🔴 현금대기",
                            '신호강도': f"{s.signal_strength:+.1f}%",
                            '권장비중': f"{s.recommended_weight*100:.1f}%"
                        })

                    signal_df = pd.DataFrame(signal_data)
                    st.dataframe(signal_df, use_container_width=True)

                    # 신호 차트
                    signals_chart = create_signals_chart(signals)
                    if signals_chart:
                        st.plotly_chart(signals_chart, use_container_width=True)

                # 포트폴리오 권장사항
                st.subheader("💼 권장 포트폴리오 구성")
                if portfolio_weights:
                    portfolio_data = []
                    for asset, weight in sorted(portfolio_weights.items(),
                                                key=lambda x: x[1], reverse=True):
                        if weight > 0.001:
                            investment_amount = initial_capital * weight
                            portfolio_data.append({
                                '자산': asset,
                                '권장 비중': f"{weight*100:.1f}%",
                                '투자 금액': f"${investment_amount:,.0f}",
                                '상태': "현금 대기" if asset == 'CASH' else "투자 대상"
                            })

                    portfolio_df = pd.DataFrame(portfolio_data)
                    st.dataframe(portfolio_df, use_container_width=True)

                # 상세 성과 표
                st.header("📋 상세 성과 분석")
                col1, col2 = st.columns(2)
                with col1:
                    st.subheader("동적자산배분 전략")
                    strategy_detail = pd.DataFrame([
                        {
                            '지표': k,
                            '값': (
                                f"{v:.3f}" if isinstance(v, (int, float)) and k != 'Final Value'
                                else f"${v:,.0f}" if k == 'Final Value'
                                else str(v)
                            )
                        }
                        for k, v in strategy_metrics.items()
                    ])  # ← 리스트 및 괄호 닫기
                    st.dataframe(strategy_detail, use_container_width=True)

                with col2:
                    st.subheader("Buy & Hold 벤치마크")
                    benchmark_detail = pd.DataFrame([
                        {
                            '지표': k,
                            '값': (
                                f"{v:.3f}" if isinstance(v, (int, float)) and k != 'Final Value'
                                else f"${v:,.0f}" if k == 'Final Value'
                                else str(v)
                            )
                        }
                        for k, v in benchmark_metrics.items()
                    ])  # ← 리스트 및 pd.DataFrame 괄호를 정확히 닫음
                    st.dataframe(benchmark_detail, use_container_width=True)

                # 데이터 다운로드
                st.header("💾 결과 다운로드")
                col1, col2, col3 = st.columns(3)
                with col1:
                    if not strategy_df.empty:
                        csv = strategy_df.to_csv()
                        st.download_button(
                            label="📊 포트폴리오 히스토리",
                            data=csv,
                            file_name=f"portfolio_history_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                with col2:
                    if signals:
                        signals_csv = signal_df.to_csv(index=False)
                        st.download_button(
                            label="🎯 실시간 신호",
                            data=signals_csv,
                            file_name=f"live_signals_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )
                with col3:
                    if trade_log:
                        trade_df = pd.DataFrame(trade_log)
                        trade_csv = trade_df.to_csv(index=False)
                        st.download_button(
                            label="📈 거래 내역",
                            data=trade_csv,
                            file_name=f"trade_log_{datetime.now().strftime('%Y%m%d')}.csv",
                            mime="text/csv",
                            use_container_width=True
                        )

    except Exception as e:
        st.error(f"❌ 앱 실행 중 오류가 발생했습니다: {e}")
        st.error("페이지를 새로고침하고 다시 시도해주세요.")
        with st.expander("상세 오류 정보"):
            st.code(traceback.format_exc())

if __name__ == "__main__":
    main()